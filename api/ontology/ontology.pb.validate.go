// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/ontology/ontology.proto

package ontology

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ResourceID with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceID with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceIDMultiError, or
// nil if none found.
func (m *ResourceID) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResourceIDMultiError(errors)
	}

	return nil
}

// ResourceIDMultiError is an error wrapping multiple validation errors
// returned by ResourceID.ValidateAll() if the designated constraints aren't met.
type ResourceIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceIDMultiError) AllErrors() []error { return m }

// ResourceIDValidationError is the validation error returned by
// ResourceID.Validate if the designated constraints aren't met.
type ResourceIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceIDValidationError) ErrorName() string { return "ResourceIDValidationError" }

// Error satisfies the builtin error interface
func (e ResourceIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceIDValidationError{}

// Validate checks the field values on AnomalyDetection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AnomalyDetection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnomalyDetection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnomalyDetectionMultiError, or nil if none found.
func (m *AnomalyDetection) ValidateAll() error {
	return m.validate(true)
}

func (m *AnomalyDetection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetApplicationLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnomalyDetectionValidationError{
					field:  "ApplicationLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnomalyDetectionValidationError{
					field:  "ApplicationLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplicationLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnomalyDetectionValidationError{
				field:  "ApplicationLogging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AnomalyDetectionMultiError(errors)
	}

	return nil
}

// AnomalyDetectionMultiError is an error wrapping multiple validation errors
// returned by AnomalyDetection.ValidateAll() if the designated constraints
// aren't met.
type AnomalyDetectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnomalyDetectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnomalyDetectionMultiError) AllErrors() []error { return m }

// AnomalyDetectionValidationError is the validation error returned by
// AnomalyDetection.Validate if the designated constraints aren't met.
type AnomalyDetectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnomalyDetectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnomalyDetectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnomalyDetectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnomalyDetectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnomalyDetectionValidationError) ErrorName() string { return "AnomalyDetectionValidationError" }

// Error satisfies the builtin error interface
func (e AnomalyDetectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnomalyDetection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnomalyDetectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnomalyDetectionValidationError{}

// Validate checks the field values on Networking with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Networking) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Networking with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetworkingMultiError, or
// nil if none found.
func (m *Networking) ValidateAll() error {
	return m.validate(true)
}

func (m *Networking) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Networking_NetworkInterface:
		if v == nil {
			err := NetworkingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNetworkInterface()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "NetworkInterface",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "NetworkInterface",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNetworkInterface()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  "NetworkInterface",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Networking_NetworkSecurityGroup:
		if v == nil {
			err := NetworkingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNetworkSecurityGroup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "NetworkSecurityGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "NetworkSecurityGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNetworkSecurityGroup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  "NetworkSecurityGroup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Networking_NetworkService:
		if v == nil {
			err := NetworkingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNetworkService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "NetworkService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "NetworkService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNetworkService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  "NetworkService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Networking_VirtualNetwork:
		if v == nil {
			err := NetworkingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVirtualNetwork()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "VirtualNetwork",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "VirtualNetwork",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVirtualNetwork()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  "VirtualNetwork",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Networking_VirtualSubNetwork:
		if v == nil {
			err := NetworkingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVirtualSubNetwork()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "VirtualSubNetwork",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  "VirtualSubNetwork",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVirtualSubNetwork()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  "VirtualSubNetwork",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return NetworkingMultiError(errors)
	}

	return nil
}

// NetworkingMultiError is an error wrapping multiple validation errors
// returned by Networking.ValidateAll() if the designated constraints aren't met.
type NetworkingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkingMultiError) AllErrors() []error { return m }

// NetworkingValidationError is the validation error returned by
// Networking.Validate if the designated constraints aren't met.
type NetworkingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkingValidationError) ErrorName() string { return "NetworkingValidationError" }

// Error satisfies the builtin error interface
func (e NetworkingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworking.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkingValidationError{}

// Validate checks the field values on CustomerKeyEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CustomerKeyEncryption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomerKeyEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CustomerKeyEncryptionMultiError, or nil if none found.
func (m *CustomerKeyEncryption) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomerKeyEncryption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for KeyUrl

	if len(errors) > 0 {
		return CustomerKeyEncryptionMultiError(errors)
	}

	return nil
}

// CustomerKeyEncryptionMultiError is an error wrapping multiple validation
// errors returned by CustomerKeyEncryption.ValidateAll() if the designated
// constraints aren't met.
type CustomerKeyEncryptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomerKeyEncryptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomerKeyEncryptionMultiError) AllErrors() []error { return m }

// CustomerKeyEncryptionValidationError is the validation error returned by
// CustomerKeyEncryption.Validate if the designated constraints aren't met.
type CustomerKeyEncryptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomerKeyEncryptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomerKeyEncryptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomerKeyEncryptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomerKeyEncryptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomerKeyEncryptionValidationError) ErrorName() string {
	return "CustomerKeyEncryptionValidationError"
}

// Error satisfies the builtin error interface
func (e CustomerKeyEncryptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomerKeyEncryption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomerKeyEncryptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomerKeyEncryptionValidationError{}

// Validate checks the field values on DatabaseQuery with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatabaseQuery) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatabaseQuery with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatabaseQueryMultiError, or
// nil if none found.
func (m *DatabaseQuery) ValidateAll() error {
	return m.validate(true)
}

func (m *DatabaseQuery) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Modify

	if len(errors) > 0 {
		return DatabaseQueryMultiError(errors)
	}

	return nil
}

// DatabaseQueryMultiError is an error wrapping multiple validation errors
// returned by DatabaseQuery.ValidateAll() if the designated constraints
// aren't met.
type DatabaseQueryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseQueryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseQueryMultiError) AllErrors() []error { return m }

// DatabaseQueryValidationError is the validation error returned by
// DatabaseQuery.Validate if the designated constraints aren't met.
type DatabaseQueryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseQueryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseQueryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseQueryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseQueryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseQueryValidationError) ErrorName() string { return "DatabaseQueryValidationError" }

// Error satisfies the builtin error interface
func (e DatabaseQueryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabaseQuery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseQueryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseQueryValidationError{}

// Validate checks the field values on ProxiedEndpoint with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProxiedEndpoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProxiedEndpoint with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProxiedEndpointMultiError, or nil if none found.
func (m *ProxiedEndpoint) ValidateAll() error {
	return m.validate(true)
}

func (m *ProxiedEndpoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HttpEndpoint

	if len(errors) > 0 {
		return ProxiedEndpointMultiError(errors)
	}

	return nil
}

// ProxiedEndpointMultiError is an error wrapping multiple validation errors
// returned by ProxiedEndpoint.ValidateAll() if the designated constraints
// aren't met.
type ProxiedEndpointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProxiedEndpointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProxiedEndpointMultiError) AllErrors() []error { return m }

// ProxiedEndpointValidationError is the validation error returned by
// ProxiedEndpoint.Validate if the designated constraints aren't met.
type ProxiedEndpointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProxiedEndpointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProxiedEndpointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProxiedEndpointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProxiedEndpointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProxiedEndpointValidationError) ErrorName() string { return "ProxiedEndpointValidationError" }

// Error satisfies the builtin error interface
func (e ProxiedEndpointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProxiedEndpoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProxiedEndpointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProxiedEndpointValidationError{}

// Validate checks the field values on Identifiable with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Identifiable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Identifiable with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IdentifiableMultiError, or
// nil if none found.
func (m *Identifiable) ValidateAll() error {
	return m.validate(true)
}

func (m *Identifiable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Activated

	if all {
		switch v := interface{}(m.GetAuthenticity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IdentifiableValidationError{
					field:  "Authenticity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IdentifiableValidationError{
					field:  "Authenticity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthenticity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IdentifiableValidationError{
				field:  "Authenticity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAuthorization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IdentifiableValidationError{
					field:  "Authorization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IdentifiableValidationError{
					field:  "Authorization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthorization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IdentifiableValidationError{
				field:  "Authorization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *Identifiable_Identity:
		if v == nil {
			err := IdentifiableValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIdentity()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IdentifiableValidationError{
						field:  "Identity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IdentifiableValidationError{
						field:  "Identity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIdentity()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IdentifiableValidationError{
					field:  "Identity",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Identifiable_RoleAssignment:
		if v == nil {
			err := IdentifiableValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRoleAssignment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IdentifiableValidationError{
						field:  "RoleAssignment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IdentifiableValidationError{
						field:  "RoleAssignment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRoleAssignment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IdentifiableValidationError{
					field:  "RoleAssignment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return IdentifiableMultiError(errors)
	}

	return nil
}

// IdentifiableMultiError is an error wrapping multiple validation errors
// returned by Identifiable.ValidateAll() if the designated constraints aren't met.
type IdentifiableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IdentifiableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IdentifiableMultiError) AllErrors() []error { return m }

// IdentifiableValidationError is the validation error returned by
// Identifiable.Validate if the designated constraints aren't met.
type IdentifiableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IdentifiableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IdentifiableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IdentifiableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IdentifiableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IdentifiableValidationError) ErrorName() string { return "IdentifiableValidationError" }

// Error satisfies the builtin error interface
func (e IdentifiableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIdentifiable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IdentifiableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IdentifiableValidationError{}

// Validate checks the field values on Compute with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Compute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Compute with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ComputeMultiError, or nil if none found.
func (m *Compute) ValidateAll() error {
	return m.validate(true)
}

func (m *Compute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNetworkInterface() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  fmt.Sprintf("NetworkInterface[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  fmt.Sprintf("NetworkInterface[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeValidationError{
					field:  fmt.Sprintf("NetworkInterface[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetEncryptionInUse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputeValidationError{
					field:  "EncryptionInUse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputeValidationError{
					field:  "EncryptionInUse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEncryptionInUse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputeValidationError{
				field:  "EncryptionInUse",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResourceLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputeValidationError{
					field:  "ResourceLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputeValidationError{
					field:  "ResourceLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputeValidationError{
				field:  "ResourceLogging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *Compute_Container:
		if v == nil {
			err := ComputeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetContainer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  "Container",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  "Container",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetContainer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Compute_Function:
		if v == nil {
			err := ComputeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFunction()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  "Function",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  "Function",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFunction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeValidationError{
					field:  "Function",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Compute_VirtualMachine:
		if v == nil {
			err := ComputeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVirtualMachine()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  "VirtualMachine",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  "VirtualMachine",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVirtualMachine()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeValidationError{
					field:  "VirtualMachine",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Compute_WebApp:
		if v == nil {
			err := ComputeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWebApp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  "WebApp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  "WebApp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebApp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeValidationError{
					field:  "WebApp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ComputeMultiError(errors)
	}

	return nil
}

// ComputeMultiError is an error wrapping multiple validation errors returned
// by Compute.ValidateAll() if the designated constraints aren't met.
type ComputeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputeMultiError) AllErrors() []error { return m }

// ComputeValidationError is the validation error returned by Compute.Validate
// if the designated constraints aren't met.
type ComputeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputeValidationError) ErrorName() string { return "ComputeValidationError" }

// Error satisfies the builtin error interface
func (e ComputeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputeValidationError{}

// Validate checks the field values on Confidentiality with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Confidentiality) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Confidentiality with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfidentialityMultiError, or nil if none found.
func (m *Confidentiality) ValidateAll() error {
	return m.validate(true)
}

func (m *Confidentiality) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Confidentiality_AtRestEncryption:
		if v == nil {
			err := ConfidentialityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAtRestEncryption()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfidentialityValidationError{
						field:  "AtRestEncryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfidentialityValidationError{
						field:  "AtRestEncryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAtRestEncryption()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfidentialityValidationError{
					field:  "AtRestEncryption",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Confidentiality_CipherSuite:
		if v == nil {
			err := ConfidentialityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCipherSuite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfidentialityValidationError{
						field:  "CipherSuite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfidentialityValidationError{
						field:  "CipherSuite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCipherSuite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfidentialityValidationError{
					field:  "CipherSuite",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Confidentiality_EncryptionInUse:
		if v == nil {
			err := ConfidentialityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEncryptionInUse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfidentialityValidationError{
						field:  "EncryptionInUse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfidentialityValidationError{
						field:  "EncryptionInUse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEncryptionInUse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfidentialityValidationError{
					field:  "EncryptionInUse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Confidentiality_TransportEncryption:
		if v == nil {
			err := ConfidentialityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransportEncryption()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfidentialityValidationError{
						field:  "TransportEncryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfidentialityValidationError{
						field:  "TransportEncryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransportEncryption()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfidentialityValidationError{
					field:  "TransportEncryption",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConfidentialityMultiError(errors)
	}

	return nil
}

// ConfidentialityMultiError is an error wrapping multiple validation errors
// returned by Confidentiality.ValidateAll() if the designated constraints
// aren't met.
type ConfidentialityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfidentialityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfidentialityMultiError) AllErrors() []error { return m }

// ConfidentialityValidationError is the validation error returned by
// Confidentiality.Validate if the designated constraints aren't met.
type ConfidentialityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfidentialityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfidentialityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfidentialityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfidentialityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfidentialityValidationError) ErrorName() string { return "ConfidentialityValidationError" }

// Error satisfies the builtin error interface
func (e ConfidentialityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfidentiality.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfidentialityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfidentialityValidationError{}

// Validate checks the field values on DatabaseStorage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DatabaseStorage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatabaseStorage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DatabaseStorageMultiError, or nil if none found.
func (m *DatabaseStorage) ValidateAll() error {
	return m.validate(true)
}

func (m *DatabaseStorage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Storage

	if len(errors) > 0 {
		return DatabaseStorageMultiError(errors)
	}

	return nil
}

// DatabaseStorageMultiError is an error wrapping multiple validation errors
// returned by DatabaseStorage.ValidateAll() if the designated constraints
// aren't met.
type DatabaseStorageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseStorageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseStorageMultiError) AllErrors() []error { return m }

// DatabaseStorageValidationError is the validation error returned by
// DatabaseStorage.Validate if the designated constraints aren't met.
type DatabaseStorageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseStorageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseStorageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseStorageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseStorageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseStorageValidationError) ErrorName() string { return "DatabaseStorageValidationError" }

// Error satisfies the builtin error interface
func (e DatabaseStorageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabaseStorage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseStorageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseStorageValidationError{}

// Validate checks the field values on FileStorageService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FileStorageService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileStorageService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FileStorageServiceMultiError, or nil if none found.
func (m *FileStorageService) ValidateAll() error {
	return m.validate(true)
}

func (m *FileStorageService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHttpEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileStorageServiceValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileStorageServiceValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHttpEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileStorageServiceValidationError{
				field:  "HttpEndpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FileStorageServiceMultiError(errors)
	}

	return nil
}

// FileStorageServiceMultiError is an error wrapping multiple validation errors
// returned by FileStorageService.ValidateAll() if the designated constraints
// aren't met.
type FileStorageServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileStorageServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileStorageServiceMultiError) AllErrors() []error { return m }

// FileStorageServiceValidationError is the validation error returned by
// FileStorageService.Validate if the designated constraints aren't met.
type FileStorageServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileStorageServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileStorageServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileStorageServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileStorageServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileStorageServiceValidationError) ErrorName() string {
	return "FileStorageServiceValidationError"
}

// Error satisfies the builtin error interface
func (e FileStorageServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileStorageService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileStorageServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileStorageServiceValidationError{}

// Validate checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplicationMultiError, or
// nil if none found.
func (m *Application) ValidateAll() error {
	return m.validate(true)
}

func (m *Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProgrammingLanguage

	for idx, item := range m.GetFunctionality() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Functionality[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Functionality[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("Functionality[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCompute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "Compute",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplicationMultiError(errors)
	}

	return nil
}

// ApplicationMultiError is an error wrapping multiple validation errors
// returned by Application.ValidateAll() if the designated constraints aren't met.
type ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationMultiError) AllErrors() []error { return m }

// ApplicationValidationError is the validation error returned by
// Application.Validate if the designated constraints aren't met.
type ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationValidationError) ErrorName() string { return "ApplicationValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationValidationError{}

// Validate checks the field values on Framework with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Framework) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Framework with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FrameworkMultiError, or nil
// if none found.
func (m *Framework) ValidateAll() error {
	return m.validate(true)
}

func (m *Framework) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Framework_CloudSDK:
		if v == nil {
			err := FrameworkValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCloudSDK()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FrameworkValidationError{
						field:  "CloudSDK",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FrameworkValidationError{
						field:  "CloudSDK",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCloudSDK()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FrameworkValidationError{
					field:  "CloudSDK",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Framework_HttpClientLibrary:
		if v == nil {
			err := FrameworkValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHttpClientLibrary()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FrameworkValidationError{
						field:  "HttpClientLibrary",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FrameworkValidationError{
						field:  "HttpClientLibrary",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHttpClientLibrary()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FrameworkValidationError{
					field:  "HttpClientLibrary",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Framework_HttpServer:
		if v == nil {
			err := FrameworkValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHttpServer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FrameworkValidationError{
						field:  "HttpServer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FrameworkValidationError{
						field:  "HttpServer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHttpServer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FrameworkValidationError{
					field:  "HttpServer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Framework_Logger:
		if v == nil {
			err := FrameworkValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLogger()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FrameworkValidationError{
						field:  "Logger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FrameworkValidationError{
						field:  "Logger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLogger()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FrameworkValidationError{
					field:  "Logger",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FrameworkMultiError(errors)
	}

	return nil
}

// FrameworkMultiError is an error wrapping multiple validation errors returned
// by Framework.ValidateAll() if the designated constraints aren't met.
type FrameworkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrameworkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrameworkMultiError) AllErrors() []error { return m }

// FrameworkValidationError is the validation error returned by
// Framework.Validate if the designated constraints aren't met.
type FrameworkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrameworkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrameworkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrameworkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrameworkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrameworkValidationError) ErrorName() string { return "FrameworkValidationError" }

// Error satisfies the builtin error interface
func (e FrameworkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFramework.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrameworkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrameworkValidationError{}

// Validate checks the field values on MessagingHub with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MessagingHub) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MessagingHub with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MessagingHubMultiError, or
// nil if none found.
func (m *MessagingHub) ValidateAll() error {
	return m.validate(true)
}

func (m *MessagingHub) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MessagingHubMultiError(errors)
	}

	return nil
}

// MessagingHubMultiError is an error wrapping multiple validation errors
// returned by MessagingHub.ValidateAll() if the designated constraints aren't met.
type MessagingHubMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessagingHubMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessagingHubMultiError) AllErrors() []error { return m }

// MessagingHubValidationError is the validation error returned by
// MessagingHub.Validate if the designated constraints aren't met.
type MessagingHubValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessagingHubValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessagingHubValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessagingHubValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessagingHubValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessagingHubValidationError) ErrorName() string { return "MessagingHubValidationError" }

// Error satisfies the builtin error interface
func (e MessagingHubValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessagingHub.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessagingHubValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessagingHubValidationError{}

// Validate checks the field values on CloudResource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudResource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudResourceMultiError, or
// nil if none found.
func (m *CloudResource) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGeoLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudResourceValidationError{
					field:  "GeoLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudResourceValidationError{
					field:  "GeoLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeoLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudResourceValidationError{
				field:  "GeoLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *CloudResource_Account:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAccount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Account",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Account",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_CICDService:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCICDService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "CICDService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "CICDService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCICDService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "CICDService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_Compute:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCompute()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Compute",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Compute",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCompute()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_ContainerOrchestration:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetContainerOrchestration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "ContainerOrchestration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "ContainerOrchestration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetContainerOrchestration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "ContainerOrchestration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_ContainerRegistry:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetContainerRegistry()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "ContainerRegistry",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "ContainerRegistry",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetContainerRegistry()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "ContainerRegistry",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_Identifiable:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIdentifiable()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Identifiable",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Identifiable",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIdentifiable()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "Identifiable",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_Image:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetImage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Image",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Image",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetImage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_IoT:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIoT()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "IoT",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "IoT",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIoT()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "IoT",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_Key:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKey()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Key",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Key",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKey()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_KeyVault:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKeyVault()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "KeyVault",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "KeyVault",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKeyVault()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "KeyVault",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_Networking:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNetworking()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Networking",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Networking",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNetworking()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "Networking",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_PasswordPolicy:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPasswordPolicy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "PasswordPolicy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "PasswordPolicy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPasswordPolicy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "PasswordPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_ResourceGroup:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetResourceGroup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "ResourceGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "ResourceGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResourceGroup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "ResourceGroup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CloudResource_Storage:
		if v == nil {
			err := CloudResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Storage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudResourceValidationError{
						field:  "Storage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudResourceValidationError{
					field:  "Storage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CloudResourceMultiError(errors)
	}

	return nil
}

// CloudResourceMultiError is an error wrapping multiple validation errors
// returned by CloudResource.ValidateAll() if the designated constraints
// aren't met.
type CloudResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudResourceMultiError) AllErrors() []error { return m }

// CloudResourceValidationError is the validation error returned by
// CloudResource.Validate if the designated constraints aren't met.
type CloudResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudResourceValidationError) ErrorName() string { return "CloudResourceValidationError" }

// Error satisfies the builtin error interface
func (e CloudResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudResourceValidationError{}

// Validate checks the field values on DatabaseConnect with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DatabaseConnect) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatabaseConnect with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DatabaseConnectMultiError, or nil if none found.
func (m *DatabaseConnect) ValidateAll() error {
	return m.validate(true)
}

func (m *DatabaseConnect) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DatabaseConnectMultiError(errors)
	}

	return nil
}

// DatabaseConnectMultiError is an error wrapping multiple validation errors
// returned by DatabaseConnect.ValidateAll() if the designated constraints
// aren't met.
type DatabaseConnectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseConnectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseConnectMultiError) AllErrors() []error { return m }

// DatabaseConnectValidationError is the validation error returned by
// DatabaseConnect.Validate if the designated constraints aren't met.
type DatabaseConnectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseConnectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseConnectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseConnectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseConnectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseConnectValidationError) ErrorName() string { return "DatabaseConnectValidationError" }

// Error satisfies the builtin error interface
func (e DatabaseConnectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabaseConnect.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseConnectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseConnectValidationError{}

// Validate checks the field values on VirtualMachine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VirtualMachine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VirtualMachine with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VirtualMachineMultiError,
// or nil if none found.
func (m *VirtualMachine) ValidateAll() error {
	return m.validate(true)
}

func (m *VirtualMachine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBlockStorage() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VirtualMachineValidationError{
						field:  fmt.Sprintf("BlockStorage[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VirtualMachineValidationError{
						field:  fmt.Sprintf("BlockStorage[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VirtualMachineValidationError{
					field:  fmt.Sprintf("BlockStorage[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetActivityLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "ActivityLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "ActivityLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActivityLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "ActivityLogging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAutomaticSecurityUpdates()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "AutomaticSecurityUpdates",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "AutomaticSecurityUpdates",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutomaticSecurityUpdates()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "AutomaticSecurityUpdates",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBootLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "BootLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "BootLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBootLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "BootLogging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMalwareProtection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "MalwareProtection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "MalwareProtection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMalwareProtection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "MalwareProtection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOSLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "OSLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "OSLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOSLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "OSLogging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VirtualMachineMultiError(errors)
	}

	return nil
}

// VirtualMachineMultiError is an error wrapping multiple validation errors
// returned by VirtualMachine.ValidateAll() if the designated constraints
// aren't met.
type VirtualMachineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VirtualMachineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VirtualMachineMultiError) AllErrors() []error { return m }

// VirtualMachineValidationError is the validation error returned by
// VirtualMachine.Validate if the designated constraints aren't met.
type VirtualMachineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VirtualMachineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VirtualMachineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VirtualMachineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VirtualMachineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VirtualMachineValidationError) ErrorName() string { return "VirtualMachineValidationError" }

// Error satisfies the builtin error interface
func (e VirtualMachineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVirtualMachine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VirtualMachineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VirtualMachineValidationError{}

// Validate checks the field values on AccessRestriction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AccessRestriction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccessRestriction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccessRestrictionMultiError, or nil if none found.
func (m *AccessRestriction) ValidateAll() error {
	return m.validate(true)
}

func (m *AccessRestriction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *AccessRestriction_Firewall:
		if v == nil {
			err := AccessRestrictionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFirewall()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AccessRestrictionValidationError{
						field:  "Firewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AccessRestrictionValidationError{
						field:  "Firewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFirewall()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AccessRestrictionValidationError{
					field:  "Firewall",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AccessRestrictionMultiError(errors)
	}

	return nil
}

// AccessRestrictionMultiError is an error wrapping multiple validation errors
// returned by AccessRestriction.ValidateAll() if the designated constraints
// aren't met.
type AccessRestrictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccessRestrictionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccessRestrictionMultiError) AllErrors() []error { return m }

// AccessRestrictionValidationError is the validation error returned by
// AccessRestriction.Validate if the designated constraints aren't met.
type AccessRestrictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccessRestrictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccessRestrictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccessRestrictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccessRestrictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccessRestrictionValidationError) ErrorName() string {
	return "AccessRestrictionValidationError"
}

// Error satisfies the builtin error interface
func (e AccessRestrictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccessRestriction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccessRestrictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccessRestrictionValidationError{}

// Validate checks the field values on NoAuthentication with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NoAuthentication) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoAuthentication with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NoAuthenticationMultiError, or nil if none found.
func (m *NoAuthentication) ValidateAll() error {
	return m.validate(true)
}

func (m *NoAuthentication) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NoAuthenticationMultiError(errors)
	}

	return nil
}

// NoAuthenticationMultiError is an error wrapping multiple validation errors
// returned by NoAuthentication.ValidateAll() if the designated constraints
// aren't met.
type NoAuthenticationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoAuthenticationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoAuthenticationMultiError) AllErrors() []error { return m }

// NoAuthenticationValidationError is the validation error returned by
// NoAuthentication.Validate if the designated constraints aren't met.
type NoAuthenticationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoAuthenticationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoAuthenticationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoAuthenticationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoAuthenticationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoAuthenticationValidationError) ErrorName() string { return "NoAuthenticationValidationError" }

// Error satisfies the builtin error interface
func (e NoAuthenticationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoAuthentication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoAuthenticationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoAuthenticationValidationError{}

// Validate checks the field values on VirtualSubNetwork with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VirtualSubNetwork) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VirtualSubNetwork with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VirtualSubNetworkMultiError, or nil if none found.
func (m *VirtualSubNetwork) ValidateAll() error {
	return m.validate(true)
}

func (m *VirtualSubNetwork) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return VirtualSubNetworkMultiError(errors)
	}

	return nil
}

// VirtualSubNetworkMultiError is an error wrapping multiple validation errors
// returned by VirtualSubNetwork.ValidateAll() if the designated constraints
// aren't met.
type VirtualSubNetworkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VirtualSubNetworkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VirtualSubNetworkMultiError) AllErrors() []error { return m }

// VirtualSubNetworkValidationError is the validation error returned by
// VirtualSubNetwork.Validate if the designated constraints aren't met.
type VirtualSubNetworkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VirtualSubNetworkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VirtualSubNetworkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VirtualSubNetworkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VirtualSubNetworkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VirtualSubNetworkValidationError) ErrorName() string {
	return "VirtualSubNetworkValidationError"
}

// Error satisfies the builtin error interface
func (e VirtualSubNetworkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVirtualSubNetwork.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VirtualSubNetworkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VirtualSubNetworkValidationError{}

// Validate checks the field values on NetworkInterface with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NetworkInterface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkInterface with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NetworkInterfaceMultiError, or nil if none found.
func (m *NetworkInterface) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkInterface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNetworkService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetworkInterfaceValidationError{
					field:  "NetworkService",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetworkInterfaceValidationError{
					field:  "NetworkService",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetworkInterfaceValidationError{
				field:  "NetworkService",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NetworkInterfaceMultiError(errors)
	}

	return nil
}

// NetworkInterfaceMultiError is an error wrapping multiple validation errors
// returned by NetworkInterface.ValidateAll() if the designated constraints
// aren't met.
type NetworkInterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkInterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkInterfaceMultiError) AllErrors() []error { return m }

// NetworkInterfaceValidationError is the validation error returned by
// NetworkInterface.Validate if the designated constraints aren't met.
type NetworkInterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkInterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkInterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkInterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkInterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkInterfaceValidationError) ErrorName() string { return "NetworkInterfaceValidationError" }

// Error satisfies the builtin error interface
func (e NetworkInterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkInterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkInterfaceValidationError{}

// Validate checks the field values on ResourceGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceGroupMultiError, or
// nil if none found.
func (m *ResourceGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResourceGroupMultiError(errors)
	}

	return nil
}

// ResourceGroupMultiError is an error wrapping multiple validation errors
// returned by ResourceGroup.ValidateAll() if the designated constraints
// aren't met.
type ResourceGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceGroupMultiError) AllErrors() []error { return m }

// ResourceGroupValidationError is the validation error returned by
// ResourceGroup.Validate if the designated constraints aren't met.
type ResourceGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceGroupValidationError) ErrorName() string { return "ResourceGroupValidationError" }

// Error satisfies the builtin error interface
func (e ResourceGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceGroupValidationError{}

// Validate checks the field values on SingleSignOn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SingleSignOn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SingleSignOn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SingleSignOnMultiError, or
// nil if none found.
func (m *SingleSignOn) ValidateAll() error {
	return m.validate(true)
}

func (m *SingleSignOn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return SingleSignOnMultiError(errors)
	}

	return nil
}

// SingleSignOnMultiError is an error wrapping multiple validation errors
// returned by SingleSignOn.ValidateAll() if the designated constraints aren't met.
type SingleSignOnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SingleSignOnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SingleSignOnMultiError) AllErrors() []error { return m }

// SingleSignOnValidationError is the validation error returned by
// SingleSignOn.Validate if the designated constraints aren't met.
type SingleSignOnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SingleSignOnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SingleSignOnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SingleSignOnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SingleSignOnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SingleSignOnValidationError) ErrorName() string { return "SingleSignOnValidationError" }

// Error satisfies the builtin error interface
func (e SingleSignOnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSingleSignOn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SingleSignOnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SingleSignOnValidationError{}

// Validate checks the field values on AtRestEncryption with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AtRestEncryption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AtRestEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AtRestEncryptionMultiError, or nil if none found.
func (m *AtRestEncryption) ValidateAll() error {
	return m.validate(true)
}

func (m *AtRestEncryption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Algorithm

	// no validation rules for Enabled

	// no validation rules for KeyUrl

	switch v := m.Type.(type) {
	case *AtRestEncryption_CustomerKeyEncryption:
		if v == nil {
			err := AtRestEncryptionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCustomerKeyEncryption()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AtRestEncryptionValidationError{
						field:  "CustomerKeyEncryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AtRestEncryptionValidationError{
						field:  "CustomerKeyEncryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustomerKeyEncryption()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AtRestEncryptionValidationError{
					field:  "CustomerKeyEncryption",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AtRestEncryption_ManagedKeyEncryption:
		if v == nil {
			err := AtRestEncryptionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetManagedKeyEncryption()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AtRestEncryptionValidationError{
						field:  "ManagedKeyEncryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AtRestEncryptionValidationError{
						field:  "ManagedKeyEncryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetManagedKeyEncryption()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AtRestEncryptionValidationError{
					field:  "ManagedKeyEncryption",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AtRestEncryptionMultiError(errors)
	}

	return nil
}

// AtRestEncryptionMultiError is an error wrapping multiple validation errors
// returned by AtRestEncryption.ValidateAll() if the designated constraints
// aren't met.
type AtRestEncryptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AtRestEncryptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AtRestEncryptionMultiError) AllErrors() []error { return m }

// AtRestEncryptionValidationError is the validation error returned by
// AtRestEncryption.Validate if the designated constraints aren't met.
type AtRestEncryptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AtRestEncryptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AtRestEncryptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AtRestEncryptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AtRestEncryptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AtRestEncryptionValidationError) ErrorName() string { return "AtRestEncryptionValidationError" }

// Error satisfies the builtin error interface
func (e AtRestEncryptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAtRestEncryption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AtRestEncryptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AtRestEncryptionValidationError{}

// Validate checks the field values on ContainerOrchestration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContainerOrchestration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerOrchestration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContainerOrchestrationMultiError, or nil if none found.
func (m *ContainerOrchestration) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerOrchestration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ManagementUrl

	if all {
		switch v := interface{}(m.GetResourceLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerOrchestrationValidationError{
					field:  "ResourceLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerOrchestrationValidationError{
					field:  "ResourceLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerOrchestrationValidationError{
				field:  "ResourceLogging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetContainer() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ContainerOrchestrationValidationError{
						field:  fmt.Sprintf("Container[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ContainerOrchestrationValidationError{
						field:  fmt.Sprintf("Container[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ContainerOrchestrationValidationError{
					field:  fmt.Sprintf("Container[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ContainerOrchestrationMultiError(errors)
	}

	return nil
}

// ContainerOrchestrationMultiError is an error wrapping multiple validation
// errors returned by ContainerOrchestration.ValidateAll() if the designated
// constraints aren't met.
type ContainerOrchestrationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerOrchestrationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerOrchestrationMultiError) AllErrors() []error { return m }

// ContainerOrchestrationValidationError is the validation error returned by
// ContainerOrchestration.Validate if the designated constraints aren't met.
type ContainerOrchestrationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerOrchestrationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerOrchestrationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerOrchestrationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerOrchestrationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerOrchestrationValidationError) ErrorName() string {
	return "ContainerOrchestrationValidationError"
}

// Error satisfies the builtin error interface
func (e ContainerOrchestrationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerOrchestration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerOrchestrationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerOrchestrationValidationError{}

// Validate checks the field values on DatabaseService with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DatabaseService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatabaseService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DatabaseServiceMultiError, or nil if none found.
func (m *DatabaseService) ValidateAll() error {
	return m.validate(true)
}

func (m *DatabaseService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHttpEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatabaseServiceValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatabaseServiceValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHttpEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatabaseServiceValidationError{
				field:  "HttpEndpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMalwareProtection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatabaseServiceValidationError{
					field:  "MalwareProtection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatabaseServiceValidationError{
					field:  "MalwareProtection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMalwareProtection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatabaseServiceValidationError{
				field:  "MalwareProtection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *DatabaseService_DocumentDatabaseService:
		if v == nil {
			err := DatabaseServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDocumentDatabaseService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatabaseServiceValidationError{
						field:  "DocumentDatabaseService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatabaseServiceValidationError{
						field:  "DocumentDatabaseService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDocumentDatabaseService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatabaseServiceValidationError{
					field:  "DocumentDatabaseService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DatabaseService_KeyValueDatabaseService:
		if v == nil {
			err := DatabaseServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKeyValueDatabaseService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatabaseServiceValidationError{
						field:  "KeyValueDatabaseService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatabaseServiceValidationError{
						field:  "KeyValueDatabaseService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKeyValueDatabaseService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatabaseServiceValidationError{
					field:  "KeyValueDatabaseService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DatabaseService_RelationalDatabaseService:
		if v == nil {
			err := DatabaseServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationalDatabaseService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatabaseServiceValidationError{
						field:  "RelationalDatabaseService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatabaseServiceValidationError{
						field:  "RelationalDatabaseService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationalDatabaseService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatabaseServiceValidationError{
					field:  "RelationalDatabaseService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DatabaseServiceMultiError(errors)
	}

	return nil
}

// DatabaseServiceMultiError is an error wrapping multiple validation errors
// returned by DatabaseService.ValidateAll() if the designated constraints
// aren't met.
type DatabaseServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseServiceMultiError) AllErrors() []error { return m }

// DatabaseServiceValidationError is the validation error returned by
// DatabaseService.Validate if the designated constraints aren't met.
type DatabaseServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseServiceValidationError) ErrorName() string { return "DatabaseServiceValidationError" }

// Error satisfies the builtin error interface
func (e DatabaseServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabaseService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseServiceValidationError{}

// Validate checks the field values on FileStorage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileStorage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileStorage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileStorageMultiError, or
// nil if none found.
func (m *FileStorage) ValidateAll() error {
	return m.validate(true)
}

func (m *FileStorage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FileStorageMultiError(errors)
	}

	return nil
}

// FileStorageMultiError is an error wrapping multiple validation errors
// returned by FileStorage.ValidateAll() if the designated constraints aren't met.
type FileStorageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileStorageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileStorageMultiError) AllErrors() []error { return m }

// FileStorageValidationError is the validation error returned by
// FileStorage.Validate if the designated constraints aren't met.
type FileStorageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileStorageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileStorageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileStorageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileStorageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileStorageValidationError) ErrorName() string { return "FileStorageValidationError" }

// Error satisfies the builtin error interface
func (e FileStorageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileStorage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileStorageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileStorageValidationError{}

// Validate checks the field values on IoT with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *IoT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IoT with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IoTMultiError, or nil if none found.
func (m *IoT) ValidateAll() error {
	return m.validate(true)
}

func (m *IoT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *IoT_DeviceProvisioningService:
		if v == nil {
			err := IoTValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeviceProvisioningService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IoTValidationError{
						field:  "DeviceProvisioningService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IoTValidationError{
						field:  "DeviceProvisioningService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeviceProvisioningService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IoTValidationError{
					field:  "DeviceProvisioningService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *IoT_MessagingHub:
		if v == nil {
			err := IoTValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMessagingHub()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IoTValidationError{
						field:  "MessagingHub",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IoTValidationError{
						field:  "MessagingHub",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessagingHub()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IoTValidationError{
					field:  "MessagingHub",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return IoTMultiError(errors)
	}

	return nil
}

// IoTMultiError is an error wrapping multiple validation errors returned by
// IoT.ValidateAll() if the designated constraints aren't met.
type IoTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IoTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IoTMultiError) AllErrors() []error { return m }

// IoTValidationError is the validation error returned by IoT.Validate if the
// designated constraints aren't met.
type IoTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IoTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IoTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IoTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IoTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IoTValidationError) ErrorName() string { return "IoTValidationError" }

// Error satisfies the builtin error interface
func (e IoTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIoT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IoTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IoTValidationError{}

// Validate checks the field values on Authenticity with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Authenticity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Authenticity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthenticityMultiError, or
// nil if none found.
func (m *Authenticity) ValidateAll() error {
	return m.validate(true)
}

func (m *Authenticity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Authenticity_CertificateBasedAuthentication:
		if v == nil {
			err := AuthenticityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCertificateBasedAuthentication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "CertificateBasedAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "CertificateBasedAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCertificateBasedAuthentication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticityValidationError{
					field:  "CertificateBasedAuthentication",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Authenticity_TokenBasedAuthentication:
		if v == nil {
			err := AuthenticityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTokenBasedAuthentication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "TokenBasedAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "TokenBasedAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTokenBasedAuthentication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticityValidationError{
					field:  "TokenBasedAuthentication",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Authenticity_NoAuthentication:
		if v == nil {
			err := AuthenticityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNoAuthentication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "NoAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "NoAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNoAuthentication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticityValidationError{
					field:  "NoAuthentication",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Authenticity_OTPBasedAuthentication:
		if v == nil {
			err := AuthenticityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOTPBasedAuthentication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "OTPBasedAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "OTPBasedAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOTPBasedAuthentication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticityValidationError{
					field:  "OTPBasedAuthentication",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Authenticity_PasswordBasedAuthentication:
		if v == nil {
			err := AuthenticityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPasswordBasedAuthentication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "PasswordBasedAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "PasswordBasedAuthentication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPasswordBasedAuthentication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticityValidationError{
					field:  "PasswordBasedAuthentication",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Authenticity_SingleSignOn:
		if v == nil {
			err := AuthenticityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSingleSignOn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "SingleSignOn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticityValidationError{
						field:  "SingleSignOn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSingleSignOn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticityValidationError{
					field:  "SingleSignOn",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AuthenticityMultiError(errors)
	}

	return nil
}

// AuthenticityMultiError is an error wrapping multiple validation errors
// returned by Authenticity.ValidateAll() if the designated constraints aren't met.
type AuthenticityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticityMultiError) AllErrors() []error { return m }

// AuthenticityValidationError is the validation error returned by
// Authenticity.Validate if the designated constraints aren't met.
type AuthenticityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticityValidationError) ErrorName() string { return "AuthenticityValidationError" }

// Error satisfies the builtin error interface
func (e AuthenticityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticityValidationError{}

// Validate checks the field values on CipherSuite with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CipherSuite) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CipherSuite with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CipherSuiteMultiError, or
// nil if none found.
func (m *CipherSuite) ValidateAll() error {
	return m.validate(true)
}

func (m *CipherSuite) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CipherSuiteMultiError(errors)
	}

	return nil
}

// CipherSuiteMultiError is an error wrapping multiple validation errors
// returned by CipherSuite.ValidateAll() if the designated constraints aren't met.
type CipherSuiteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CipherSuiteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CipherSuiteMultiError) AllErrors() []error { return m }

// CipherSuiteValidationError is the validation error returned by
// CipherSuite.Validate if the designated constraints aren't met.
type CipherSuiteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CipherSuiteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CipherSuiteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CipherSuiteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CipherSuiteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CipherSuiteValidationError) ErrorName() string { return "CipherSuiteValidationError" }

// Error satisfies the builtin error interface
func (e CipherSuiteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCipherSuite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CipherSuiteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CipherSuiteValidationError{}

// Validate checks the field values on EncryptionInUse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EncryptionInUse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EncryptionInUse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EncryptionInUseMultiError, or nil if none found.
func (m *EncryptionInUse) ValidateAll() error {
	return m.validate(true)
}

func (m *EncryptionInUse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return EncryptionInUseMultiError(errors)
	}

	return nil
}

// EncryptionInUseMultiError is an error wrapping multiple validation errors
// returned by EncryptionInUse.ValidateAll() if the designated constraints
// aren't met.
type EncryptionInUseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EncryptionInUseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EncryptionInUseMultiError) AllErrors() []error { return m }

// EncryptionInUseValidationError is the validation error returned by
// EncryptionInUse.Validate if the designated constraints aren't met.
type EncryptionInUseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EncryptionInUseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EncryptionInUseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EncryptionInUseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EncryptionInUseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EncryptionInUseValidationError) ErrorName() string { return "EncryptionInUseValidationError" }

// Error satisfies the builtin error interface
func (e EncryptionInUseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEncryptionInUse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EncryptionInUseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EncryptionInUseValidationError{}

// Validate checks the field values on LoadBalancer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadBalancer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadBalancer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadBalancerMultiError, or
// nil if none found.
func (m *LoadBalancer) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadBalancer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	for idx, item := range m.GetHttpEndpoint() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoadBalancerValidationError{
						field:  fmt.Sprintf("HttpEndpoint[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoadBalancerValidationError{
						field:  fmt.Sprintf("HttpEndpoint[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadBalancerValidationError{
					field:  fmt.Sprintf("HttpEndpoint[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetNetworkService() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoadBalancerValidationError{
						field:  fmt.Sprintf("NetworkService[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoadBalancerValidationError{
						field:  fmt.Sprintf("NetworkService[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadBalancerValidationError{
					field:  fmt.Sprintf("NetworkService[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoadBalancerMultiError(errors)
	}

	return nil
}

// LoadBalancerMultiError is an error wrapping multiple validation errors
// returned by LoadBalancer.ValidateAll() if the designated constraints aren't met.
type LoadBalancerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadBalancerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadBalancerMultiError) AllErrors() []error { return m }

// LoadBalancerValidationError is the validation error returned by
// LoadBalancer.Validate if the designated constraints aren't met.
type LoadBalancerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadBalancerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadBalancerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadBalancerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadBalancerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadBalancerValidationError) ErrorName() string { return "LoadBalancerValidationError" }

// Error satisfies the builtin error interface
func (e LoadBalancerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadBalancer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadBalancerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadBalancerValidationError{}

// Validate checks the field values on BlockStorage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlockStorage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockStorage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlockStorageMultiError, or
// nil if none found.
func (m *BlockStorage) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockStorage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BlockStorageMultiError(errors)
	}

	return nil
}

// BlockStorageMultiError is an error wrapping multiple validation errors
// returned by BlockStorage.ValidateAll() if the designated constraints aren't met.
type BlockStorageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockStorageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockStorageMultiError) AllErrors() []error { return m }

// BlockStorageValidationError is the validation error returned by
// BlockStorage.Validate if the designated constraints aren't met.
type BlockStorageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockStorageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockStorageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockStorageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockStorageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockStorageValidationError) ErrorName() string { return "BlockStorageValidationError" }

// Error satisfies the builtin error interface
func (e BlockStorageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockStorage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockStorageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockStorageValidationError{}

// Validate checks the field values on Functionality with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Functionality) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Functionality with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FunctionalityMultiError, or
// nil if none found.
func (m *Functionality) ValidateAll() error {
	return m.validate(true)
}

func (m *Functionality) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Functionality_HttpEndpoint:
		if v == nil {
			err := FunctionalityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHttpEndpoint()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FunctionalityValidationError{
						field:  "HttpEndpoint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FunctionalityValidationError{
						field:  "HttpEndpoint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHttpEndpoint()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FunctionalityValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Functionality_HttpRequestHandler:
		if v == nil {
			err := FunctionalityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHttpRequestHandler()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FunctionalityValidationError{
						field:  "HttpRequestHandler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FunctionalityValidationError{
						field:  "HttpRequestHandler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHttpRequestHandler()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FunctionalityValidationError{
					field:  "HttpRequestHandler",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Functionality_Operation:
		if v == nil {
			err := FunctionalityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOperation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FunctionalityValidationError{
						field:  "Operation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FunctionalityValidationError{
						field:  "Operation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOperation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FunctionalityValidationError{
					field:  "Operation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FunctionalityMultiError(errors)
	}

	return nil
}

// FunctionalityMultiError is an error wrapping multiple validation errors
// returned by Functionality.ValidateAll() if the designated constraints
// aren't met.
type FunctionalityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FunctionalityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FunctionalityMultiError) AllErrors() []error { return m }

// FunctionalityValidationError is the validation error returned by
// Functionality.Validate if the designated constraints aren't met.
type FunctionalityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FunctionalityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FunctionalityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FunctionalityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FunctionalityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FunctionalityValidationError) ErrorName() string { return "FunctionalityValidationError" }

// Error satisfies the builtin error interface
func (e FunctionalityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFunctionality.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FunctionalityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FunctionalityValidationError{}

// Validate checks the field values on TokenBasedAuthentication with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenBasedAuthentication) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenBasedAuthentication with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenBasedAuthenticationMultiError, or nil if none found.
func (m *TokenBasedAuthentication) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenBasedAuthentication) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Enforced

	if len(errors) > 0 {
		return TokenBasedAuthenticationMultiError(errors)
	}

	return nil
}

// TokenBasedAuthenticationMultiError is an error wrapping multiple validation
// errors returned by TokenBasedAuthentication.ValidateAll() if the designated
// constraints aren't met.
type TokenBasedAuthenticationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenBasedAuthenticationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenBasedAuthenticationMultiError) AllErrors() []error { return m }

// TokenBasedAuthenticationValidationError is the validation error returned by
// TokenBasedAuthentication.Validate if the designated constraints aren't met.
type TokenBasedAuthenticationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenBasedAuthenticationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenBasedAuthenticationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenBasedAuthenticationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenBasedAuthenticationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenBasedAuthenticationValidationError) ErrorName() string {
	return "TokenBasedAuthenticationValidationError"
}

// Error satisfies the builtin error interface
func (e TokenBasedAuthenticationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenBasedAuthentication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenBasedAuthenticationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenBasedAuthenticationValidationError{}

// Validate checks the field values on Logging with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Logging) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Logging with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LoggingMultiError, or nil if none found.
func (m *Logging) ValidateAll() error {
	return m.validate(true)
}

func (m *Logging) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetLoggingService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoggingValidationError{
					field:  "LoggingService",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoggingValidationError{
					field:  "LoggingService",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoggingService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoggingValidationError{
				field:  "LoggingService",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *Logging_ActivityLogging:
		if v == nil {
			err := LoggingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetActivityLogging()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "ActivityLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "ActivityLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActivityLogging()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoggingValidationError{
					field:  "ActivityLogging",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Logging_ApplicationLogging:
		if v == nil {
			err := LoggingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplicationLogging()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "ApplicationLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "ApplicationLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationLogging()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoggingValidationError{
					field:  "ApplicationLogging",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Logging_BootLogging:
		if v == nil {
			err := LoggingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBootLogging()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "BootLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "BootLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBootLogging()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoggingValidationError{
					field:  "BootLogging",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Logging_OSLogging:
		if v == nil {
			err := LoggingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOSLogging()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "OSLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "OSLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOSLogging()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoggingValidationError{
					field:  "OSLogging",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Logging_ResourceLogging:
		if v == nil {
			err := LoggingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetResourceLogging()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "ResourceLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoggingValidationError{
						field:  "ResourceLogging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResourceLogging()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoggingValidationError{
					field:  "ResourceLogging",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return LoggingMultiError(errors)
	}

	return nil
}

// LoggingMultiError is an error wrapping multiple validation errors returned
// by Logging.ValidateAll() if the designated constraints aren't met.
type LoggingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoggingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoggingMultiError) AllErrors() []error { return m }

// LoggingValidationError is the validation error returned by Logging.Validate
// if the designated constraints aren't met.
type LoggingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoggingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoggingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoggingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoggingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoggingValidationError) ErrorName() string { return "LoggingValidationError" }

// Error satisfies the builtin error interface
func (e LoggingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogging.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoggingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoggingValidationError{}

// Validate checks the field values on Redundancy with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Redundancy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Redundancy with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RedundancyMultiError, or
// nil if none found.
func (m *Redundancy) ValidateAll() error {
	return m.validate(true)
}

func (m *Redundancy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RedundancyMultiError(errors)
	}

	return nil
}

// RedundancyMultiError is an error wrapping multiple validation errors
// returned by Redundancy.ValidateAll() if the designated constraints aren't met.
type RedundancyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RedundancyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RedundancyMultiError) AllErrors() []error { return m }

// RedundancyValidationError is the validation error returned by
// Redundancy.Validate if the designated constraints aren't met.
type RedundancyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RedundancyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RedundancyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RedundancyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RedundancyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RedundancyValidationError) ErrorName() string { return "RedundancyValidationError" }

// Error satisfies the builtin error interface
func (e RedundancyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRedundancy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RedundancyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RedundancyValidationError{}

// Validate checks the field values on HttpClientLibrary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HttpClientLibrary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HttpClientLibrary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HttpClientLibraryMultiError, or nil if none found.
func (m *HttpClientLibrary) ValidateAll() error {
	return m.validate(true)
}

func (m *HttpClientLibrary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HttpClientLibraryMultiError(errors)
	}

	return nil
}

// HttpClientLibraryMultiError is an error wrapping multiple validation errors
// returned by HttpClientLibrary.ValidateAll() if the designated constraints
// aren't met.
type HttpClientLibraryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HttpClientLibraryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HttpClientLibraryMultiError) AllErrors() []error { return m }

// HttpClientLibraryValidationError is the validation error returned by
// HttpClientLibrary.Validate if the designated constraints aren't met.
type HttpClientLibraryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpClientLibraryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpClientLibraryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpClientLibraryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpClientLibraryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpClientLibraryValidationError) ErrorName() string {
	return "HttpClientLibraryValidationError"
}

// Error satisfies the builtin error interface
func (e HttpClientLibraryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpClientLibrary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpClientLibraryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpClientLibraryValidationError{}

// Validate checks the field values on RBAC with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *RBAC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RBAC with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RBACMultiError, or nil if none found.
func (m *RBAC) ValidateAll() error {
	return m.validate(true)
}

func (m *RBAC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RBACMultiError(errors)
	}

	return nil
}

// RBACMultiError is an error wrapping multiple validation errors returned by
// RBAC.ValidateAll() if the designated constraints aren't met.
type RBACMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RBACMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RBACMultiError) AllErrors() []error { return m }

// RBACValidationError is the validation error returned by RBAC.Validate if the
// designated constraints aren't met.
type RBACValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RBACValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RBACValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RBACValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RBACValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RBACValidationError) ErrorName() string { return "RBACValidationError" }

// Error satisfies the builtin error interface
func (e RBACValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRBAC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RBACValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RBACValidationError{}

// Validate checks the field values on ManagedKeyEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManagedKeyEncryption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManagedKeyEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManagedKeyEncryptionMultiError, or nil if none found.
func (m *ManagedKeyEncryption) ValidateAll() error {
	return m.validate(true)
}

func (m *ManagedKeyEncryption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ManagedKeyEncryptionMultiError(errors)
	}

	return nil
}

// ManagedKeyEncryptionMultiError is an error wrapping multiple validation
// errors returned by ManagedKeyEncryption.ValidateAll() if the designated
// constraints aren't met.
type ManagedKeyEncryptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManagedKeyEncryptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManagedKeyEncryptionMultiError) AllErrors() []error { return m }

// ManagedKeyEncryptionValidationError is the validation error returned by
// ManagedKeyEncryption.Validate if the designated constraints aren't met.
type ManagedKeyEncryptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManagedKeyEncryptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManagedKeyEncryptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManagedKeyEncryptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManagedKeyEncryptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManagedKeyEncryptionValidationError) ErrorName() string {
	return "ManagedKeyEncryptionValidationError"
}

// Error satisfies the builtin error interface
func (e ManagedKeyEncryptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManagedKeyEncryption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManagedKeyEncryptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManagedKeyEncryptionValidationError{}

// Validate checks the field values on Container with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Container) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Container with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerMultiError, or nil
// if none found.
func (m *Container) ValidateAll() error {
	return m.validate(true)
}

func (m *Container) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetImage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerValidationError{
				field:  "Image",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContainerMultiError(errors)
	}

	return nil
}

// ContainerMultiError is an error wrapping multiple validation errors returned
// by Container.ValidateAll() if the designated constraints aren't met.
type ContainerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerMultiError) AllErrors() []error { return m }

// ContainerValidationError is the validation error returned by
// Container.Validate if the designated constraints aren't met.
type ContainerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerValidationError) ErrorName() string { return "ContainerValidationError" }

// Error satisfies the builtin error interface
func (e ContainerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerValidationError{}

// Validate checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Account) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AccountMultiError, or nil if none found.
func (m *Account) ValidateAll() error {
	return m.validate(true)
}

func (m *Account) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AccountMultiError(errors)
	}

	return nil
}

// AccountMultiError is an error wrapping multiple validation errors returned
// by Account.ValidateAll() if the designated constraints aren't met.
type AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountMultiError) AllErrors() []error { return m }

// AccountValidationError is the validation error returned by Account.Validate
// if the designated constraints aren't met.
type AccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountValidationError) ErrorName() string { return "AccountValidationError" }

// Error satisfies the builtin error interface
func (e AccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountValidationError{}

// Validate checks the field values on DatabaseOperation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DatabaseOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatabaseOperation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DatabaseOperationMultiError, or nil if none found.
func (m *DatabaseOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *DatabaseOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDatabaseStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatabaseOperationValidationError{
					field:  "DatabaseStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatabaseOperationValidationError{
					field:  "DatabaseStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatabaseStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatabaseOperationValidationError{
				field:  "DatabaseStorage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatabaseService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatabaseOperationValidationError{
					field:  "DatabaseService",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatabaseOperationValidationError{
					field:  "DatabaseService",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatabaseService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatabaseOperationValidationError{
				field:  "DatabaseService",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *DatabaseOperation_DatabaseConnect:
		if v == nil {
			err := DatabaseOperationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDatabaseConnect()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatabaseOperationValidationError{
						field:  "DatabaseConnect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatabaseOperationValidationError{
						field:  "DatabaseConnect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabaseConnect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatabaseOperationValidationError{
					field:  "DatabaseConnect",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DatabaseOperation_DatabaseQuery:
		if v == nil {
			err := DatabaseOperationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDatabaseQuery()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatabaseOperationValidationError{
						field:  "DatabaseQuery",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatabaseOperationValidationError{
						field:  "DatabaseQuery",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabaseQuery()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatabaseOperationValidationError{
					field:  "DatabaseQuery",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DatabaseOperationMultiError(errors)
	}

	return nil
}

// DatabaseOperationMultiError is an error wrapping multiple validation errors
// returned by DatabaseOperation.ValidateAll() if the designated constraints
// aren't met.
type DatabaseOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseOperationMultiError) AllErrors() []error { return m }

// DatabaseOperationValidationError is the validation error returned by
// DatabaseOperation.Validate if the designated constraints aren't met.
type DatabaseOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseOperationValidationError) ErrorName() string {
	return "DatabaseOperationValidationError"
}

// Error satisfies the builtin error interface
func (e DatabaseOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabaseOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseOperationValidationError{}

// Validate checks the field values on OTPBasedAuthentication with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OTPBasedAuthentication) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OTPBasedAuthentication with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OTPBasedAuthenticationMultiError, or nil if none found.
func (m *OTPBasedAuthentication) ValidateAll() error {
	return m.validate(true)
}

func (m *OTPBasedAuthentication) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Activated

	if len(errors) > 0 {
		return OTPBasedAuthenticationMultiError(errors)
	}

	return nil
}

// OTPBasedAuthenticationMultiError is an error wrapping multiple validation
// errors returned by OTPBasedAuthentication.ValidateAll() if the designated
// constraints aren't met.
type OTPBasedAuthenticationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OTPBasedAuthenticationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OTPBasedAuthenticationMultiError) AllErrors() []error { return m }

// OTPBasedAuthenticationValidationError is the validation error returned by
// OTPBasedAuthentication.Validate if the designated constraints aren't met.
type OTPBasedAuthenticationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OTPBasedAuthenticationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OTPBasedAuthenticationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OTPBasedAuthenticationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OTPBasedAuthenticationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OTPBasedAuthenticationValidationError) ErrorName() string {
	return "OTPBasedAuthenticationValidationError"
}

// Error satisfies the builtin error interface
func (e OTPBasedAuthenticationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOTPBasedAuthentication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OTPBasedAuthenticationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OTPBasedAuthenticationValidationError{}

// Validate checks the field values on Workflow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Workflow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Workflow with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowMultiError, or nil
// if none found.
func (m *Workflow) ValidateAll() error {
	return m.validate(true)
}

func (m *Workflow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return WorkflowMultiError(errors)
	}

	return nil
}

// WorkflowMultiError is an error wrapping multiple validation errors returned
// by Workflow.ValidateAll() if the designated constraints aren't met.
type WorkflowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowMultiError) AllErrors() []error { return m }

// WorkflowValidationError is the validation error returned by
// Workflow.Validate if the designated constraints aren't met.
type WorkflowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowValidationError) ErrorName() string { return "WorkflowValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowValidationError{}

// Validate checks the field values on ActivityLogging with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ActivityLogging) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivityLogging with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivityLoggingMultiError, or nil if none found.
func (m *ActivityLogging) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivityLogging) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ActivityLoggingMultiError(errors)
	}

	return nil
}

// ActivityLoggingMultiError is an error wrapping multiple validation errors
// returned by ActivityLogging.ValidateAll() if the designated constraints
// aren't met.
type ActivityLoggingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivityLoggingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivityLoggingMultiError) AllErrors() []error { return m }

// ActivityLoggingValidationError is the validation error returned by
// ActivityLogging.Validate if the designated constraints aren't met.
type ActivityLoggingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivityLoggingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivityLoggingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivityLoggingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivityLoggingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivityLoggingValidationError) ErrorName() string { return "ActivityLoggingValidationError" }

// Error satisfies the builtin error interface
func (e ActivityLoggingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivityLogging.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivityLoggingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivityLoggingValidationError{}

// Validate checks the field values on DeviceProvisioningService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeviceProvisioningService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeviceProvisioningService with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeviceProvisioningServiceMultiError, or nil if none found.
func (m *DeviceProvisioningService) ValidateAll() error {
	return m.validate(true)
}

func (m *DeviceProvisioningService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeviceProvisioningServiceMultiError(errors)
	}

	return nil
}

// DeviceProvisioningServiceMultiError is an error wrapping multiple validation
// errors returned by DeviceProvisioningService.ValidateAll() if the
// designated constraints aren't met.
type DeviceProvisioningServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeviceProvisioningServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeviceProvisioningServiceMultiError) AllErrors() []error { return m }

// DeviceProvisioningServiceValidationError is the validation error returned by
// DeviceProvisioningService.Validate if the designated constraints aren't met.
type DeviceProvisioningServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeviceProvisioningServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeviceProvisioningServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeviceProvisioningServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeviceProvisioningServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeviceProvisioningServiceValidationError) ErrorName() string {
	return "DeviceProvisioningServiceValidationError"
}

// Error satisfies the builtin error interface
func (e DeviceProvisioningServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeviceProvisioningService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeviceProvisioningServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeviceProvisioningServiceValidationError{}

// Validate checks the field values on HttpEndpoint with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HttpEndpoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HttpEndpoint with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HttpEndpointMultiError, or
// nil if none found.
func (m *HttpEndpoint) ValidateAll() error {
	return m.validate(true)
}

func (m *HttpEndpoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Method

	// no validation rules for Path

	// no validation rules for Url

	if all {
		switch v := interface{}(m.GetAuthenticity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HttpEndpointValidationError{
					field:  "Authenticity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HttpEndpointValidationError{
					field:  "Authenticity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthenticity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpEndpointValidationError{
				field:  "Authenticity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransportEncryption()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HttpEndpointValidationError{
					field:  "TransportEncryption",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HttpEndpointValidationError{
					field:  "TransportEncryption",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportEncryption()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpEndpointValidationError{
				field:  "TransportEncryption",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *HttpEndpoint_ProxiedEndpoint:
		if v == nil {
			err := HttpEndpointValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProxiedEndpoint()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HttpEndpointValidationError{
						field:  "ProxiedEndpoint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HttpEndpointValidationError{
						field:  "ProxiedEndpoint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProxiedEndpoint()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HttpEndpointValidationError{
					field:  "ProxiedEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return HttpEndpointMultiError(errors)
	}

	return nil
}

// HttpEndpointMultiError is an error wrapping multiple validation errors
// returned by HttpEndpoint.ValidateAll() if the designated constraints aren't met.
type HttpEndpointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HttpEndpointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HttpEndpointMultiError) AllErrors() []error { return m }

// HttpEndpointValidationError is the validation error returned by
// HttpEndpoint.Validate if the designated constraints aren't met.
type HttpEndpointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpEndpointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpEndpointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpEndpointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpEndpointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpEndpointValidationError) ErrorName() string { return "HttpEndpointValidationError" }

// Error satisfies the builtin error interface
func (e HttpEndpointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpEndpoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpEndpointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpEndpointValidationError{}

// Validate checks the field values on ObjectStorageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ObjectStorageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectStorageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectStorageRequestMultiError, or nil if none found.
func (m *ObjectStorageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectStorageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetObjectStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectStorageRequestValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectStorageRequestValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectStorageRequestValidationError{
				field:  "ObjectStorage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ObjectStorageRequestMultiError(errors)
	}

	return nil
}

// ObjectStorageRequestMultiError is an error wrapping multiple validation
// errors returned by ObjectStorageRequest.ValidateAll() if the designated
// constraints aren't met.
type ObjectStorageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectStorageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectStorageRequestMultiError) AllErrors() []error { return m }

// ObjectStorageRequestValidationError is the validation error returned by
// ObjectStorageRequest.Validate if the designated constraints aren't met.
type ObjectStorageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectStorageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectStorageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectStorageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectStorageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectStorageRequestValidationError) ErrorName() string {
	return "ObjectStorageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ObjectStorageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectStorageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectStorageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectStorageRequestValidationError{}

// Validate checks the field values on BootLogging with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BootLogging) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BootLogging with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BootLoggingMultiError, or
// nil if none found.
func (m *BootLogging) ValidateAll() error {
	return m.validate(true)
}

func (m *BootLogging) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BootLoggingMultiError(errors)
	}

	return nil
}

// BootLoggingMultiError is an error wrapping multiple validation errors
// returned by BootLogging.ValidateAll() if the designated constraints aren't met.
type BootLoggingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BootLoggingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BootLoggingMultiError) AllErrors() []error { return m }

// BootLoggingValidationError is the validation error returned by
// BootLogging.Validate if the designated constraints aren't met.
type BootLoggingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BootLoggingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BootLoggingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BootLoggingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BootLoggingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BootLoggingValidationError) ErrorName() string { return "BootLoggingValidationError" }

// Error satisfies the builtin error interface
func (e BootLoggingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBootLogging.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BootLoggingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BootLoggingValidationError{}

// Validate checks the field values on Job with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Job) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Job with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobMultiError, or nil if none found.
func (m *Job) ValidateAll() error {
	return m.validate(true)
}

func (m *Job) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return JobMultiError(errors)
	}

	return nil
}

// JobMultiError is an error wrapping multiple validation errors returned by
// Job.ValidateAll() if the designated constraints aren't met.
type JobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobMultiError) AllErrors() []error { return m }

// JobValidationError is the validation error returned by Job.Validate if the
// designated constraints aren't met.
type JobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobValidationError) ErrorName() string { return "JobValidationError" }

// Error satisfies the builtin error interface
func (e JobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobValidationError{}

// Validate checks the field values on ObjectStorage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ObjectStorage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectStorage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ObjectStorageMultiError, or
// nil if none found.
func (m *ObjectStorage) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectStorage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ObjectStorageMultiError(errors)
	}

	return nil
}

// ObjectStorageMultiError is an error wrapping multiple validation errors
// returned by ObjectStorage.ValidateAll() if the designated constraints
// aren't met.
type ObjectStorageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectStorageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectStorageMultiError) AllErrors() []error { return m }

// ObjectStorageValidationError is the validation error returned by
// ObjectStorage.Validate if the designated constraints aren't met.
type ObjectStorageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectStorageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectStorageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectStorageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectStorageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectStorageValidationError) ErrorName() string { return "ObjectStorageValidationError" }

// Error satisfies the builtin error interface
func (e ObjectStorageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectStorage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectStorageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectStorageValidationError{}

// Validate checks the field values on HttpRequestHandler with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HttpRequestHandler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HttpRequestHandler with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HttpRequestHandlerMultiError, or nil if none found.
func (m *HttpRequestHandler) ValidateAll() error {
	return m.validate(true)
}

func (m *HttpRequestHandler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	if all {
		switch v := interface{}(m.GetApplication()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HttpRequestHandlerValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HttpRequestHandlerValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpRequestHandlerValidationError{
				field:  "Application",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetHttpEndpoint() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HttpRequestHandlerValidationError{
						field:  fmt.Sprintf("HttpEndpoint[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HttpRequestHandlerValidationError{
						field:  fmt.Sprintf("HttpEndpoint[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HttpRequestHandlerValidationError{
					field:  fmt.Sprintf("HttpEndpoint[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HttpRequestHandlerMultiError(errors)
	}

	return nil
}

// HttpRequestHandlerMultiError is an error wrapping multiple validation errors
// returned by HttpRequestHandler.ValidateAll() if the designated constraints
// aren't met.
type HttpRequestHandlerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HttpRequestHandlerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HttpRequestHandlerMultiError) AllErrors() []error { return m }

// HttpRequestHandlerValidationError is the validation error returned by
// HttpRequestHandler.Validate if the designated constraints aren't met.
type HttpRequestHandlerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpRequestHandlerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpRequestHandlerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpRequestHandlerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpRequestHandlerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpRequestHandlerValidationError) ErrorName() string {
	return "HttpRequestHandlerValidationError"
}

// Error satisfies the builtin error interface
func (e HttpRequestHandlerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpRequestHandler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpRequestHandlerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpRequestHandlerValidationError{}

// Validate checks the field values on LoggingService with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoggingService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoggingService with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoggingServiceMultiError,
// or nil if none found.
func (m *LoggingService) ValidateAll() error {
	return m.validate(true)
}

func (m *LoggingService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStorage() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoggingServiceValidationError{
						field:  fmt.Sprintf("Storage[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoggingServiceValidationError{
						field:  fmt.Sprintf("Storage[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoggingServiceValidationError{
					field:  fmt.Sprintf("Storage[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoggingServiceMultiError(errors)
	}

	return nil
}

// LoggingServiceMultiError is an error wrapping multiple validation errors
// returned by LoggingService.ValidateAll() if the designated constraints
// aren't met.
type LoggingServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoggingServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoggingServiceMultiError) AllErrors() []error { return m }

// LoggingServiceValidationError is the validation error returned by
// LoggingService.Validate if the designated constraints aren't met.
type LoggingServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoggingServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoggingServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoggingServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoggingServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoggingServiceValidationError) ErrorName() string { return "LoggingServiceValidationError" }

// Error satisfies the builtin error interface
func (e LoggingServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoggingService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoggingServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoggingServiceValidationError{}

// Validate checks the field values on RoleAssignment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleAssignment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleAssignment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleAssignmentMultiError,
// or nil if none found.
func (m *RoleAssignment) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleAssignment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RoleAssignmentMultiError(errors)
	}

	return nil
}

// RoleAssignmentMultiError is an error wrapping multiple validation errors
// returned by RoleAssignment.ValidateAll() if the designated constraints
// aren't met.
type RoleAssignmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleAssignmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleAssignmentMultiError) AllErrors() []error { return m }

// RoleAssignmentValidationError is the validation error returned by
// RoleAssignment.Validate if the designated constraints aren't met.
type RoleAssignmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleAssignmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleAssignmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleAssignmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleAssignmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleAssignmentValidationError) ErrorName() string { return "RoleAssignmentValidationError" }

// Error satisfies the builtin error interface
func (e RoleAssignmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleAssignment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleAssignmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleAssignmentValidationError{}

// Validate checks the field values on Backup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Backup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Backup with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BackupMultiError, or nil if none found.
func (m *Backup) ValidateAll() error {
	return m.validate(true)
}

func (m *Backup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BackupValidationError{
					field:  "Storage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BackupValidationError{
					field:  "Storage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BackupValidationError{
				field:  "Storage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BackupMultiError(errors)
	}

	return nil
}

// BackupMultiError is an error wrapping multiple validation errors returned by
// Backup.ValidateAll() if the designated constraints aren't met.
type BackupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BackupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BackupMultiError) AllErrors() []error { return m }

// BackupValidationError is the validation error returned by Backup.Validate if
// the designated constraints aren't met.
type BackupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BackupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BackupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BackupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BackupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BackupValidationError) ErrorName() string { return "BackupValidationError" }

// Error satisfies the builtin error interface
func (e BackupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBackup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BackupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BackupValidationError{}

// Validate checks the field values on Resource with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMultiError, or nil
// if none found.
func (m *Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Resource

	switch v := m.Type.(type) {
	case *Resource_Application:
		if v == nil {
			err := ResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_CloudResource:
		if v == nil {
			err := ResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCloudResource()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "CloudResource",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "CloudResource",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCloudResource()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "CloudResource",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Document:
		if v == nil {
			err := ResourceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDocument()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Document",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Document",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ResourceMultiError(errors)
	}

	return nil
}

// ResourceMultiError is an error wrapping multiple validation errors returned
// by Resource.ValidateAll() if the designated constraints aren't met.
type ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMultiError) AllErrors() []error { return m }

// ResourceValidationError is the validation error returned by
// Resource.Validate if the designated constraints aren't met.
type ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceValidationError) ErrorName() string { return "ResourceValidationError" }

// Error satisfies the builtin error interface
func (e ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceValidationError{}

// Validate checks the field values on ContainerImage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContainerImage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerImage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerImageMultiError,
// or nil if none found.
func (m *ContainerImage) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerImage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ContainerImageMultiError(errors)
	}

	return nil
}

// ContainerImageMultiError is an error wrapping multiple validation errors
// returned by ContainerImage.ValidateAll() if the designated constraints
// aren't met.
type ContainerImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerImageMultiError) AllErrors() []error { return m }

// ContainerImageValidationError is the validation error returned by
// ContainerImage.Validate if the designated constraints aren't met.
type ContainerImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerImageValidationError) ErrorName() string { return "ContainerImageValidationError" }

// Error satisfies the builtin error interface
func (e ContainerImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerImage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerImageValidationError{}

// Validate checks the field values on AutomaticSecurityUpdates with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AutomaticSecurityUpdates) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutomaticSecurityUpdates with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutomaticSecurityUpdatesMultiError, or nil if none found.
func (m *AutomaticSecurityUpdates) ValidateAll() error {
	return m.validate(true)
}

func (m *AutomaticSecurityUpdates) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return AutomaticSecurityUpdatesMultiError(errors)
	}

	return nil
}

// AutomaticSecurityUpdatesMultiError is an error wrapping multiple validation
// errors returned by AutomaticSecurityUpdates.ValidateAll() if the designated
// constraints aren't met.
type AutomaticSecurityUpdatesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutomaticSecurityUpdatesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutomaticSecurityUpdatesMultiError) AllErrors() []error { return m }

// AutomaticSecurityUpdatesValidationError is the validation error returned by
// AutomaticSecurityUpdates.Validate if the designated constraints aren't met.
type AutomaticSecurityUpdatesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutomaticSecurityUpdatesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutomaticSecurityUpdatesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutomaticSecurityUpdatesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutomaticSecurityUpdatesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutomaticSecurityUpdatesValidationError) ErrorName() string {
	return "AutomaticSecurityUpdatesValidationError"
}

// Error satisfies the builtin error interface
func (e AutomaticSecurityUpdatesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutomaticSecurityUpdates.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutomaticSecurityUpdatesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutomaticSecurityUpdatesValidationError{}

// Validate checks the field values on HttpServer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HttpServer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HttpServer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HttpServerMultiError, or
// nil if none found.
func (m *HttpServer) ValidateAll() error {
	return m.validate(true)
}

func (m *HttpServer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHttpRequestHandler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HttpServerValidationError{
					field:  "HttpRequestHandler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HttpServerValidationError{
					field:  "HttpRequestHandler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHttpRequestHandler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpServerValidationError{
				field:  "HttpRequestHandler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HttpServerMultiError(errors)
	}

	return nil
}

// HttpServerMultiError is an error wrapping multiple validation errors
// returned by HttpServer.ValidateAll() if the designated constraints aren't met.
type HttpServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HttpServerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HttpServerMultiError) AllErrors() []error { return m }

// HttpServerValidationError is the validation error returned by
// HttpServer.Validate if the designated constraints aren't met.
type HttpServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpServerValidationError) ErrorName() string { return "HttpServerValidationError" }

// Error satisfies the builtin error interface
func (e HttpServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpServerValidationError{}

// Validate checks the field values on Firewall with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Firewall) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Firewall with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirewallMultiError, or nil
// if none found.
func (m *Firewall) ValidateAll() error {
	return m.validate(true)
}

func (m *Firewall) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Firewall_L3Firewall:
		if v == nil {
			err := FirewallValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetL3Firewall()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FirewallValidationError{
						field:  "L3Firewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FirewallValidationError{
						field:  "L3Firewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetL3Firewall()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FirewallValidationError{
					field:  "L3Firewall",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Firewall_WebApplicationFirewall:
		if v == nil {
			err := FirewallValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWebApplicationFirewall()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FirewallValidationError{
						field:  "WebApplicationFirewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FirewallValidationError{
						field:  "WebApplicationFirewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebApplicationFirewall()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FirewallValidationError{
					field:  "WebApplicationFirewall",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FirewallMultiError(errors)
	}

	return nil
}

// FirewallMultiError is an error wrapping multiple validation errors returned
// by Firewall.ValidateAll() if the designated constraints aren't met.
type FirewallMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirewallMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirewallMultiError) AllErrors() []error { return m }

// FirewallValidationError is the validation error returned by
// Firewall.Validate if the designated constraints aren't met.
type FirewallValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirewallValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirewallValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirewallValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirewallValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirewallValidationError) ErrorName() string { return "FirewallValidationError" }

// Error satisfies the builtin error interface
func (e FirewallValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirewall.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirewallValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirewallValidationError{}

// Validate checks the field values on PasswordPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PasswordPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordPolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PasswordPolicyMultiError,
// or nil if none found.
func (m *PasswordPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PasswordPolicyMultiError(errors)
	}

	return nil
}

// PasswordPolicyMultiError is an error wrapping multiple validation errors
// returned by PasswordPolicy.ValidateAll() if the designated constraints
// aren't met.
type PasswordPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordPolicyMultiError) AllErrors() []error { return m }

// PasswordPolicyValidationError is the validation error returned by
// PasswordPolicy.Validate if the designated constraints aren't met.
type PasswordPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordPolicyValidationError) ErrorName() string { return "PasswordPolicyValidationError" }

// Error satisfies the builtin error interface
func (e PasswordPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordPolicyValidationError{}

// Validate checks the field values on VMImage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VMImage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VMImage with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VMImageMultiError, or nil if none found.
func (m *VMImage) ValidateAll() error {
	return m.validate(true)
}

func (m *VMImage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return VMImageMultiError(errors)
	}

	return nil
}

// VMImageMultiError is an error wrapping multiple validation errors returned
// by VMImage.ValidateAll() if the designated constraints aren't met.
type VMImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VMImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VMImageMultiError) AllErrors() []error { return m }

// VMImageValidationError is the validation error returned by VMImage.Validate
// if the designated constraints aren't met.
type VMImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VMImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VMImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VMImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VMImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VMImageValidationError) ErrorName() string { return "VMImageValidationError" }

// Error satisfies the builtin error interface
func (e VMImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVMImage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VMImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VMImageValidationError{}

// Validate checks the field values on CICDService with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CICDService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CICDService with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CICDServiceMultiError, or
// nil if none found.
func (m *CICDService) ValidateAll() error {
	return m.validate(true)
}

func (m *CICDService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *CICDService_Job:
		if v == nil {
			err := CICDServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJob()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CICDServiceValidationError{
						field:  "Job",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CICDServiceValidationError{
						field:  "Job",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CICDServiceValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CICDService_Workflow:
		if v == nil {
			err := CICDServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWorkflow()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CICDServiceValidationError{
						field:  "Workflow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CICDServiceValidationError{
						field:  "Workflow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CICDServiceValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CICDServiceMultiError(errors)
	}

	return nil
}

// CICDServiceMultiError is an error wrapping multiple validation errors
// returned by CICDService.ValidateAll() if the designated constraints aren't met.
type CICDServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CICDServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CICDServiceMultiError) AllErrors() []error { return m }

// CICDServiceValidationError is the validation error returned by
// CICDService.Validate if the designated constraints aren't met.
type CICDServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CICDServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CICDServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CICDServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CICDServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CICDServiceValidationError) ErrorName() string { return "CICDServiceValidationError" }

// Error satisfies the builtin error interface
func (e CICDServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCICDService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CICDServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CICDServiceValidationError{}

// Validate checks the field values on CertificateBasedAuthentication with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CertificateBasedAuthentication) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CertificateBasedAuthentication with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CertificateBasedAuthenticationMultiError, or nil if none found.
func (m *CertificateBasedAuthentication) ValidateAll() error {
	return m.validate(true)
}

func (m *CertificateBasedAuthentication) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return CertificateBasedAuthenticationMultiError(errors)
	}

	return nil
}

// CertificateBasedAuthenticationMultiError is an error wrapping multiple
// validation errors returned by CertificateBasedAuthentication.ValidateAll()
// if the designated constraints aren't met.
type CertificateBasedAuthenticationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CertificateBasedAuthenticationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CertificateBasedAuthenticationMultiError) AllErrors() []error { return m }

// CertificateBasedAuthenticationValidationError is the validation error
// returned by CertificateBasedAuthentication.Validate if the designated
// constraints aren't met.
type CertificateBasedAuthenticationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CertificateBasedAuthenticationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CertificateBasedAuthenticationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CertificateBasedAuthenticationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CertificateBasedAuthenticationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CertificateBasedAuthenticationValidationError) ErrorName() string {
	return "CertificateBasedAuthenticationValidationError"
}

// Error satisfies the builtin error interface
func (e CertificateBasedAuthenticationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCertificateBasedAuthentication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CertificateBasedAuthenticationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CertificateBasedAuthenticationValidationError{}

// Validate checks the field values on CloudSDK with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudSDK) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudSDK with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudSDKMultiError, or nil
// if none found.
func (m *CloudSDK) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudSDK) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CloudSDKMultiError(errors)
	}

	return nil
}

// CloudSDKMultiError is an error wrapping multiple validation errors returned
// by CloudSDK.ValidateAll() if the designated constraints aren't met.
type CloudSDKMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudSDKMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudSDKMultiError) AllErrors() []error { return m }

// CloudSDKValidationError is the validation error returned by
// CloudSDK.Validate if the designated constraints aren't met.
type CloudSDKValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudSDKValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudSDKValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudSDKValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudSDKValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudSDKValidationError) ErrorName() string { return "CloudSDKValidationError" }

// Error satisfies the builtin error interface
func (e CloudSDKValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudSDK.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudSDKValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudSDKValidationError{}

// Validate checks the field values on GeoLocation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GeoLocation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeoLocation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GeoLocationMultiError, or
// nil if none found.
func (m *GeoLocation) ValidateAll() error {
	return m.validate(true)
}

func (m *GeoLocation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	if len(errors) > 0 {
		return GeoLocationMultiError(errors)
	}

	return nil
}

// GeoLocationMultiError is an error wrapping multiple validation errors
// returned by GeoLocation.ValidateAll() if the designated constraints aren't met.
type GeoLocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeoLocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeoLocationMultiError) AllErrors() []error { return m }

// GeoLocationValidationError is the validation error returned by
// GeoLocation.Validate if the designated constraints aren't met.
type GeoLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeoLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeoLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeoLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeoLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeoLocationValidationError) ErrorName() string { return "GeoLocationValidationError" }

// Error satisfies the builtin error interface
func (e GeoLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeoLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeoLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeoLocationValidationError{}

// Validate checks the field values on LogOperation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogOperation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogOperationMultiError, or
// nil if none found.
func (m *LogOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *LogOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogOperationValidationError{
					field:  "Logging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogOperationValidationError{
					field:  "Logging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogOperationValidationError{
				field:  "Logging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogOperationMultiError(errors)
	}

	return nil
}

// LogOperationMultiError is an error wrapping multiple validation errors
// returned by LogOperation.ValidateAll() if the designated constraints aren't met.
type LogOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogOperationMultiError) AllErrors() []error { return m }

// LogOperationValidationError is the validation error returned by
// LogOperation.Validate if the designated constraints aren't met.
type LogOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogOperationValidationError) ErrorName() string { return "LogOperationValidationError" }

// Error satisfies the builtin error interface
func (e LogOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogOperationValidationError{}

// Validate checks the field values on MalwareProtection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MalwareProtection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MalwareProtection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MalwareProtectionMultiError, or nil if none found.
func (m *MalwareProtection) ValidateAll() error {
	return m.validate(true)
}

func (m *MalwareProtection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetApplicationLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MalwareProtectionValidationError{
					field:  "ApplicationLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MalwareProtectionValidationError{
					field:  "ApplicationLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplicationLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MalwareProtectionValidationError{
				field:  "ApplicationLogging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MalwareProtectionMultiError(errors)
	}

	return nil
}

// MalwareProtectionMultiError is an error wrapping multiple validation errors
// returned by MalwareProtection.ValidateAll() if the designated constraints
// aren't met.
type MalwareProtectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MalwareProtectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MalwareProtectionMultiError) AllErrors() []error { return m }

// MalwareProtectionValidationError is the validation error returned by
// MalwareProtection.Validate if the designated constraints aren't met.
type MalwareProtectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MalwareProtectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MalwareProtectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MalwareProtectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MalwareProtectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MalwareProtectionValidationError) ErrorName() string {
	return "MalwareProtectionValidationError"
}

// Error satisfies the builtin error interface
func (e MalwareProtectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMalwareProtection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MalwareProtectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MalwareProtectionValidationError{}

// Validate checks the field values on Immutability with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Immutability) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Immutability with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImmutabilityMultiError, or
// nil if none found.
func (m *Immutability) ValidateAll() error {
	return m.validate(true)
}

func (m *Immutability) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return ImmutabilityMultiError(errors)
	}

	return nil
}

// ImmutabilityMultiError is an error wrapping multiple validation errors
// returned by Immutability.ValidateAll() if the designated constraints aren't met.
type ImmutabilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImmutabilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImmutabilityMultiError) AllErrors() []error { return m }

// ImmutabilityValidationError is the validation error returned by
// Immutability.Validate if the designated constraints aren't met.
type ImmutabilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImmutabilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImmutabilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImmutabilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImmutabilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImmutabilityValidationError) ErrorName() string { return "ImmutabilityValidationError" }

// Error satisfies the builtin error interface
func (e ImmutabilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImmutability.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImmutabilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImmutabilityValidationError{}

// Validate checks the field values on Key with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Key) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Key with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KeyMultiError, or nil if none found.
func (m *Key) ValidateAll() error {
	return m.validate(true)
}

func (m *Key) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return KeyMultiError(errors)
	}

	return nil
}

// KeyMultiError is an error wrapping multiple validation errors returned by
// Key.ValidateAll() if the designated constraints aren't met.
type KeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyMultiError) AllErrors() []error { return m }

// KeyValidationError is the validation error returned by Key.Validate if the
// designated constraints aren't met.
type KeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValidationError) ErrorName() string { return "KeyValidationError" }

// Error satisfies the builtin error interface
func (e KeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKey.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValidationError{}

// Validate checks the field values on Storage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Storage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Storage with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StorageMultiError, or nil if none found.
func (m *Storage) ValidateAll() error {
	return m.validate(true)
}

func (m *Storage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBackup() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  fmt.Sprintf("Backup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  fmt.Sprintf("Backup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageValidationError{
					field:  fmt.Sprintf("Backup[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetImmutability()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageValidationError{
					field:  "Immutability",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageValidationError{
					field:  "Immutability",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImmutability()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageValidationError{
				field:  "Immutability",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRedundancy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageValidationError{
					field:  "Redundancy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageValidationError{
					field:  "Redundancy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRedundancy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageValidationError{
				field:  "Redundancy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResourceLogging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageValidationError{
					field:  "ResourceLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageValidationError{
					field:  "ResourceLogging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceLogging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageValidationError{
				field:  "ResourceLogging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *Storage_BlockStorage:
		if v == nil {
			err := StorageValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBlockStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  "BlockStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  "BlockStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBlockStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageValidationError{
					field:  "BlockStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Storage_DatabaseStorage:
		if v == nil {
			err := StorageValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDatabaseStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  "DatabaseStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  "DatabaseStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabaseStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageValidationError{
					field:  "DatabaseStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Storage_FileStorage:
		if v == nil {
			err := StorageValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFileStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  "FileStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  "FileStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFileStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageValidationError{
					field:  "FileStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Storage_ObjectStorage:
		if v == nil {
			err := StorageValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return StorageMultiError(errors)
	}

	return nil
}

// StorageMultiError is an error wrapping multiple validation errors returned
// by Storage.ValidateAll() if the designated constraints aren't met.
type StorageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageMultiError) AllErrors() []error { return m }

// StorageValidationError is the validation error returned by Storage.Validate
// if the designated constraints aren't met.
type StorageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageValidationError) ErrorName() string { return "StorageValidationError" }

// Error satisfies the builtin error interface
func (e StorageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageValidationError{}

// Validate checks the field values on WebApplicationFirewall with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebApplicationFirewall) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebApplicationFirewall with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebApplicationFirewallMultiError, or nil if none found.
func (m *WebApplicationFirewall) ValidateAll() error {
	return m.validate(true)
}

func (m *WebApplicationFirewall) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return WebApplicationFirewallMultiError(errors)
	}

	return nil
}

// WebApplicationFirewallMultiError is an error wrapping multiple validation
// errors returned by WebApplicationFirewall.ValidateAll() if the designated
// constraints aren't met.
type WebApplicationFirewallMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebApplicationFirewallMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebApplicationFirewallMultiError) AllErrors() []error { return m }

// WebApplicationFirewallValidationError is the validation error returned by
// WebApplicationFirewall.Validate if the designated constraints aren't met.
type WebApplicationFirewallValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebApplicationFirewallValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebApplicationFirewallValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebApplicationFirewallValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebApplicationFirewallValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebApplicationFirewallValidationError) ErrorName() string {
	return "WebApplicationFirewallValidationError"
}

// Error satisfies the builtin error interface
func (e WebApplicationFirewallValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebApplicationFirewall.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebApplicationFirewallValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebApplicationFirewallValidationError{}

// Validate checks the field values on Integrity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Integrity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Integrity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IntegrityMultiError, or nil
// if none found.
func (m *Integrity) ValidateAll() error {
	return m.validate(true)
}

func (m *Integrity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Integrity_AutomaticSecurityUpdates:
		if v == nil {
			err := IntegrityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAutomaticSecurityUpdates()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IntegrityValidationError{
						field:  "AutomaticSecurityUpdates",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IntegrityValidationError{
						field:  "AutomaticSecurityUpdates",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAutomaticSecurityUpdates()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IntegrityValidationError{
					field:  "AutomaticSecurityUpdates",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Integrity_Immutability:
		if v == nil {
			err := IntegrityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetImmutability()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IntegrityValidationError{
						field:  "Immutability",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IntegrityValidationError{
						field:  "Immutability",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetImmutability()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IntegrityValidationError{
					field:  "Immutability",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return IntegrityMultiError(errors)
	}

	return nil
}

// IntegrityMultiError is an error wrapping multiple validation errors returned
// by Integrity.ValidateAll() if the designated constraints aren't met.
type IntegrityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IntegrityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IntegrityMultiError) AllErrors() []error { return m }

// IntegrityValidationError is the validation error returned by
// Integrity.Validate if the designated constraints aren't met.
type IntegrityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IntegrityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IntegrityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IntegrityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IntegrityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IntegrityValidationError) ErrorName() string { return "IntegrityValidationError" }

// Error satisfies the builtin error interface
func (e IntegrityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntegrity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IntegrityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IntegrityValidationError{}

// Validate checks the field values on KeyVault with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyVault) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyVault with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyVaultMultiError, or nil
// if none found.
func (m *KeyVault) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyVault) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return KeyVaultMultiError(errors)
	}

	return nil
}

// KeyVaultMultiError is an error wrapping multiple validation errors returned
// by KeyVault.ValidateAll() if the designated constraints aren't met.
type KeyVaultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyVaultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyVaultMultiError) AllErrors() []error { return m }

// KeyVaultValidationError is the validation error returned by
// KeyVault.Validate if the designated constraints aren't met.
type KeyVaultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyVaultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyVaultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyVaultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyVaultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyVaultValidationError) ErrorName() string { return "KeyVaultValidationError" }

// Error satisfies the builtin error interface
func (e KeyVaultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyVault.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyVaultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyVaultValidationError{}

// Validate checks the field values on NetworkSecurityGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NetworkSecurityGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkSecurityGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NetworkSecurityGroupMultiError, or nil if none found.
func (m *NetworkSecurityGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkSecurityGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NetworkSecurityGroupMultiError(errors)
	}

	return nil
}

// NetworkSecurityGroupMultiError is an error wrapping multiple validation
// errors returned by NetworkSecurityGroup.ValidateAll() if the designated
// constraints aren't met.
type NetworkSecurityGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkSecurityGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkSecurityGroupMultiError) AllErrors() []error { return m }

// NetworkSecurityGroupValidationError is the validation error returned by
// NetworkSecurityGroup.Validate if the designated constraints aren't met.
type NetworkSecurityGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkSecurityGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkSecurityGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkSecurityGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkSecurityGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkSecurityGroupValidationError) ErrorName() string {
	return "NetworkSecurityGroupValidationError"
}

// Error satisfies the builtin error interface
func (e NetworkSecurityGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkSecurityGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkSecurityGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkSecurityGroupValidationError{}

// Validate checks the field values on OSLogging with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OSLogging) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OSLogging with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OSLoggingMultiError, or nil
// if none found.
func (m *OSLogging) ValidateAll() error {
	return m.validate(true)
}

func (m *OSLogging) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OSLoggingMultiError(errors)
	}

	return nil
}

// OSLoggingMultiError is an error wrapping multiple validation errors returned
// by OSLogging.ValidateAll() if the designated constraints aren't met.
type OSLoggingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OSLoggingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OSLoggingMultiError) AllErrors() []error { return m }

// OSLoggingValidationError is the validation error returned by
// OSLogging.Validate if the designated constraints aren't met.
type OSLoggingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OSLoggingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OSLoggingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OSLoggingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OSLoggingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OSLoggingValidationError) ErrorName() string { return "OSLoggingValidationError" }

// Error satisfies the builtin error interface
func (e OSLoggingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOSLogging.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OSLoggingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OSLoggingValidationError{}

// Validate checks the field values on WebApp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebApp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebApp with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in WebAppMultiError, or nil if none found.
func (m *WebApp) ValidateAll() error {
	return m.validate(true)
}

func (m *WebApp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return WebAppMultiError(errors)
	}

	return nil
}

// WebAppMultiError is an error wrapping multiple validation errors returned by
// WebApp.ValidateAll() if the designated constraints aren't met.
type WebAppMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAppMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAppMultiError) AllErrors() []error { return m }

// WebAppValidationError is the validation error returned by WebApp.Validate if
// the designated constraints aren't met.
type WebAppValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAppValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAppValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAppValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAppValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAppValidationError) ErrorName() string { return "WebAppValidationError" }

// Error satisfies the builtin error interface
func (e WebAppValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebApp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAppValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAppValidationError{}

// Validate checks the field values on ABAC with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *ABAC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABAC with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ABACMultiError, or nil if none found.
func (m *ABAC) ValidateAll() error {
	return m.validate(true)
}

func (m *ABAC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ABACMultiError(errors)
	}

	return nil
}

// ABACMultiError is an error wrapping multiple validation errors returned by
// ABAC.ValidateAll() if the designated constraints aren't met.
type ABACMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABACMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABACMultiError) AllErrors() []error { return m }

// ABACValidationError is the validation error returned by ABAC.Validate if the
// designated constraints aren't met.
type ABACValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABACValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABACValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABACValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABACValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABACValidationError) ErrorName() string { return "ABACValidationError" }

// Error satisfies the builtin error interface
func (e ABACValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABAC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABACValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABACValidationError{}

// Validate checks the field values on ContainerRegistry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContainerRegistry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerRegistry with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContainerRegistryMultiError, or nil if none found.
func (m *ContainerRegistry) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerRegistry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ContainerRegistryMultiError(errors)
	}

	return nil
}

// ContainerRegistryMultiError is an error wrapping multiple validation errors
// returned by ContainerRegistry.ValidateAll() if the designated constraints
// aren't met.
type ContainerRegistryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerRegistryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerRegistryMultiError) AllErrors() []error { return m }

// ContainerRegistryValidationError is the validation error returned by
// ContainerRegistry.Validate if the designated constraints aren't met.
type ContainerRegistryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerRegistryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerRegistryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerRegistryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerRegistryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerRegistryValidationError) ErrorName() string {
	return "ContainerRegistryValidationError"
}

// Error satisfies the builtin error interface
func (e ContainerRegistryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerRegistry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerRegistryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerRegistryValidationError{}

// Validate checks the field values on DDoSProtection with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DDoSProtection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DDoSProtection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DDoSProtectionMultiError,
// or nil if none found.
func (m *DDoSProtection) ValidateAll() error {
	return m.validate(true)
}

func (m *DDoSProtection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DDoSProtectionMultiError(errors)
	}

	return nil
}

// DDoSProtectionMultiError is an error wrapping multiple validation errors
// returned by DDoSProtection.ValidateAll() if the designated constraints
// aren't met.
type DDoSProtectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DDoSProtectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DDoSProtectionMultiError) AllErrors() []error { return m }

// DDoSProtectionValidationError is the validation error returned by
// DDoSProtection.Validate if the designated constraints aren't met.
type DDoSProtectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DDoSProtectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DDoSProtectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DDoSProtectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DDoSProtectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DDoSProtectionValidationError) ErrorName() string { return "DDoSProtectionValidationError" }

// Error satisfies the builtin error interface
func (e DDoSProtectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDDoSProtection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DDoSProtectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DDoSProtectionValidationError{}

// Validate checks the field values on NetworkService with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NetworkService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkService with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetworkServiceMultiError,
// or nil if none found.
func (m *NetworkService) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCompute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetworkServiceValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetworkServiceValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetworkServiceValidationError{
				field:  "Compute",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransportEncryption()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetworkServiceValidationError{
					field:  "TransportEncryption",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetworkServiceValidationError{
					field:  "TransportEncryption",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportEncryption()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetworkServiceValidationError{
				field:  "TransportEncryption",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *NetworkService_LoadBalancer:
		if v == nil {
			err := NetworkServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoadBalancer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkServiceValidationError{
						field:  "LoadBalancer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkServiceValidationError{
						field:  "LoadBalancer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoadBalancer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkServiceValidationError{
					field:  "LoadBalancer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *NetworkService_LoggingService:
		if v == nil {
			err := NetworkServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoggingService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkServiceValidationError{
						field:  "LoggingService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkServiceValidationError{
						field:  "LoggingService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoggingService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkServiceValidationError{
					field:  "LoggingService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *NetworkService_StorageService:
		if v == nil {
			err := NetworkServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStorageService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkServiceValidationError{
						field:  "StorageService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkServiceValidationError{
						field:  "StorageService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStorageService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkServiceValidationError{
					field:  "StorageService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return NetworkServiceMultiError(errors)
	}

	return nil
}

// NetworkServiceMultiError is an error wrapping multiple validation errors
// returned by NetworkService.ValidateAll() if the designated constraints
// aren't met.
type NetworkServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkServiceMultiError) AllErrors() []error { return m }

// NetworkServiceValidationError is the validation error returned by
// NetworkService.Validate if the designated constraints aren't met.
type NetworkServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkServiceValidationError) ErrorName() string { return "NetworkServiceValidationError" }

// Error satisfies the builtin error interface
func (e NetworkServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkServiceValidationError{}

// Validate checks the field values on Image with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Image) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Image with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ImageMultiError, or nil if none found.
func (m *Image) ValidateAll() error {
	return m.validate(true)
}

func (m *Image) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetApplication()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImageValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImageValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImageValidationError{
				field:  "Application",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Type.(type) {
	case *Image_ContainerImage:
		if v == nil {
			err := ImageValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetContainerImage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImageValidationError{
						field:  "ContainerImage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImageValidationError{
						field:  "ContainerImage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetContainerImage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImageValidationError{
					field:  "ContainerImage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Image_VMImage:
		if v == nil {
			err := ImageValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVMImage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImageValidationError{
						field:  "VMImage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImageValidationError{
						field:  "VMImage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVMImage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImageValidationError{
					field:  "VMImage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ImageMultiError(errors)
	}

	return nil
}

// ImageMultiError is an error wrapping multiple validation errors returned by
// Image.ValidateAll() if the designated constraints aren't met.
type ImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImageMultiError) AllErrors() []error { return m }

// ImageValidationError is the validation error returned by Image.Validate if
// the designated constraints aren't met.
type ImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImageValidationError) ErrorName() string { return "ImageValidationError" }

// Error satisfies the builtin error interface
func (e ImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImageValidationError{}

// Validate checks the field values on PasswordBasedAuthentication with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PasswordBasedAuthentication) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordBasedAuthentication with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PasswordBasedAuthenticationMultiError, or nil if none found.
func (m *PasswordBasedAuthentication) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordBasedAuthentication) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Activated

	if len(errors) > 0 {
		return PasswordBasedAuthenticationMultiError(errors)
	}

	return nil
}

// PasswordBasedAuthenticationMultiError is an error wrapping multiple
// validation errors returned by PasswordBasedAuthentication.ValidateAll() if
// the designated constraints aren't met.
type PasswordBasedAuthenticationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordBasedAuthenticationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordBasedAuthenticationMultiError) AllErrors() []error { return m }

// PasswordBasedAuthenticationValidationError is the validation error returned
// by PasswordBasedAuthentication.Validate if the designated constraints
// aren't met.
type PasswordBasedAuthenticationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordBasedAuthenticationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordBasedAuthenticationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordBasedAuthenticationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordBasedAuthenticationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordBasedAuthenticationValidationError) ErrorName() string {
	return "PasswordBasedAuthenticationValidationError"
}

// Error satisfies the builtin error interface
func (e PasswordBasedAuthenticationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordBasedAuthentication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordBasedAuthenticationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordBasedAuthenticationValidationError{}

// Validate checks the field values on Availability with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Availability) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Availability with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailabilityMultiError, or
// nil if none found.
func (m *Availability) ValidateAll() error {
	return m.validate(true)
}

func (m *Availability) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Availability_Backup:
		if v == nil {
			err := AvailabilityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBackup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AvailabilityValidationError{
						field:  "Backup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AvailabilityValidationError{
						field:  "Backup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBackup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AvailabilityValidationError{
					field:  "Backup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Availability_DDoSProtection:
		if v == nil {
			err := AvailabilityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDDoSProtection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AvailabilityValidationError{
						field:  "DDoSProtection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AvailabilityValidationError{
						field:  "DDoSProtection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDDoSProtection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AvailabilityValidationError{
					field:  "DDoSProtection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Availability_GeoLocation:
		if v == nil {
			err := AvailabilityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGeoLocation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AvailabilityValidationError{
						field:  "GeoLocation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AvailabilityValidationError{
						field:  "GeoLocation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGeoLocation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AvailabilityValidationError{
					field:  "GeoLocation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Availability_Redundancy:
		if v == nil {
			err := AvailabilityValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRedundancy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AvailabilityValidationError{
						field:  "Redundancy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AvailabilityValidationError{
						field:  "Redundancy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedundancy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AvailabilityValidationError{
					field:  "Redundancy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AvailabilityMultiError(errors)
	}

	return nil
}

// AvailabilityMultiError is an error wrapping multiple validation errors
// returned by Availability.ValidateAll() if the designated constraints aren't met.
type AvailabilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailabilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailabilityMultiError) AllErrors() []error { return m }

// AvailabilityValidationError is the validation error returned by
// Availability.Validate if the designated constraints aren't met.
type AvailabilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailabilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailabilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailabilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailabilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailabilityValidationError) ErrorName() string { return "AvailabilityValidationError" }

// Error satisfies the builtin error interface
func (e AvailabilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailability.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailabilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailabilityValidationError{}

// Validate checks the field values on Operation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Operation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Operation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationMultiError, or nil
// if none found.
func (m *Operation) ValidateAll() error {
	return m.validate(true)
}

func (m *Operation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Operation_DatabaseOperation:
		if v == nil {
			err := OperationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDatabaseOperation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  "DatabaseOperation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  "DatabaseOperation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabaseOperation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  "DatabaseOperation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Operation_HttpRequest:
		if v == nil {
			err := OperationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHttpRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  "HttpRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  "HttpRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHttpRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  "HttpRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Operation_LogOperation:
		if v == nil {
			err := OperationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLogOperation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  "LogOperation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  "LogOperation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLogOperation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  "LogOperation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Operation_ObjectStorageRequest:
		if v == nil {
			err := OperationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectStorageRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  "ObjectStorageRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  "ObjectStorageRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorageRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  "ObjectStorageRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return OperationMultiError(errors)
	}

	return nil
}

// OperationMultiError is an error wrapping multiple validation errors returned
// by Operation.ValidateAll() if the designated constraints aren't met.
type OperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationMultiError) AllErrors() []error { return m }

// OperationValidationError is the validation error returned by
// Operation.Validate if the designated constraints aren't met.
type OperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationValidationError) ErrorName() string { return "OperationValidationError" }

// Error satisfies the builtin error interface
func (e OperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationValidationError{}

// Validate checks the field values on StorageService with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StorageService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorageService with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StorageServiceMultiError,
// or nil if none found.
func (m *StorageService) ValidateAll() error {
	return m.validate(true)
}

func (m *StorageService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStorage() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageServiceValidationError{
						field:  fmt.Sprintf("Storage[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageServiceValidationError{
						field:  fmt.Sprintf("Storage[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageServiceValidationError{
					field:  fmt.Sprintf("Storage[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Type.(type) {
	case *StorageService_DatabaseService:
		if v == nil {
			err := StorageServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDatabaseService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageServiceValidationError{
						field:  "DatabaseService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageServiceValidationError{
						field:  "DatabaseService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabaseService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageServiceValidationError{
					field:  "DatabaseService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *StorageService_FileStorageService:
		if v == nil {
			err := StorageServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFileStorageService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageServiceValidationError{
						field:  "FileStorageService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageServiceValidationError{
						field:  "FileStorageService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFileStorageService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageServiceValidationError{
					field:  "FileStorageService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *StorageService_ObjectStorageService:
		if v == nil {
			err := StorageServiceValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectStorageService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageServiceValidationError{
						field:  "ObjectStorageService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageServiceValidationError{
						field:  "ObjectStorageService",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorageService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageServiceValidationError{
					field:  "ObjectStorageService",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return StorageServiceMultiError(errors)
	}

	return nil
}

// StorageServiceMultiError is an error wrapping multiple validation errors
// returned by StorageService.ValidateAll() if the designated constraints
// aren't met.
type StorageServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageServiceMultiError) AllErrors() []error { return m }

// StorageServiceValidationError is the validation error returned by
// StorageService.Validate if the designated constraints aren't met.
type StorageServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageServiceValidationError) ErrorName() string { return "StorageServiceValidationError" }

// Error satisfies the builtin error interface
func (e StorageServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorageService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageServiceValidationError{}

// Validate checks the field values on ApplicationLogging with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationLogging) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationLogging with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationLoggingMultiError, or nil if none found.
func (m *ApplicationLogging) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationLogging) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ApplicationLoggingMultiError(errors)
	}

	return nil
}

// ApplicationLoggingMultiError is an error wrapping multiple validation errors
// returned by ApplicationLogging.ValidateAll() if the designated constraints
// aren't met.
type ApplicationLoggingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationLoggingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationLoggingMultiError) AllErrors() []error { return m }

// ApplicationLoggingValidationError is the validation error returned by
// ApplicationLogging.Validate if the designated constraints aren't met.
type ApplicationLoggingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationLoggingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationLoggingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationLoggingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationLoggingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationLoggingValidationError) ErrorName() string {
	return "ApplicationLoggingValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationLoggingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationLogging.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationLoggingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationLoggingValidationError{}

// Validate checks the field values on Document with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Document) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Document with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocumentMultiError, or nil
// if none found.
func (m *Document) ValidateAll() error {
	return m.validate(true)
}

func (m *Document) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSecurityFeature() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("SecurityFeature[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("SecurityFeature[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentValidationError{
					field:  fmt.Sprintf("SecurityFeature[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DocumentMultiError(errors)
	}

	return nil
}

// DocumentMultiError is an error wrapping multiple validation errors returned
// by Document.ValidateAll() if the designated constraints aren't met.
type DocumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentMultiError) AllErrors() []error { return m }

// DocumentValidationError is the validation error returned by
// Document.Validate if the designated constraints aren't met.
type DocumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentValidationError) ErrorName() string { return "DocumentValidationError" }

// Error satisfies the builtin error interface
func (e DocumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentValidationError{}

// Validate checks the field values on DocumentDatabaseService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentDatabaseService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentDatabaseService with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentDatabaseServiceMultiError, or nil if none found.
func (m *DocumentDatabaseService) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentDatabaseService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DocumentDatabaseServiceMultiError(errors)
	}

	return nil
}

// DocumentDatabaseServiceMultiError is an error wrapping multiple validation
// errors returned by DocumentDatabaseService.ValidateAll() if the designated
// constraints aren't met.
type DocumentDatabaseServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentDatabaseServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentDatabaseServiceMultiError) AllErrors() []error { return m }

// DocumentDatabaseServiceValidationError is the validation error returned by
// DocumentDatabaseService.Validate if the designated constraints aren't met.
type DocumentDatabaseServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentDatabaseServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentDatabaseServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentDatabaseServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentDatabaseServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentDatabaseServiceValidationError) ErrorName() string {
	return "DocumentDatabaseServiceValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentDatabaseServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentDatabaseService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentDatabaseServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentDatabaseServiceValidationError{}

// Validate checks the field values on Logger with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Logger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Logger with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LoggerMultiError, or nil if none found.
func (m *Logger) ValidateAll() error {
	return m.validate(true)
}

func (m *Logger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LoggerMultiError(errors)
	}

	return nil
}

// LoggerMultiError is an error wrapping multiple validation errors returned by
// Logger.ValidateAll() if the designated constraints aren't met.
type LoggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoggerMultiError) AllErrors() []error { return m }

// LoggerValidationError is the validation error returned by Logger.Validate if
// the designated constraints aren't met.
type LoggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoggerValidationError) ErrorName() string { return "LoggerValidationError" }

// Error satisfies the builtin error interface
func (e LoggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoggerValidationError{}

// Validate checks the field values on Auditing with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Auditing) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Auditing with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuditingMultiError, or nil
// if none found.
func (m *Auditing) ValidateAll() error {
	return m.validate(true)
}

func (m *Auditing) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Auditing_AnomalyDetection:
		if v == nil {
			err := AuditingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAnomalyDetection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuditingValidationError{
						field:  "AnomalyDetection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuditingValidationError{
						field:  "AnomalyDetection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAnomalyDetection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuditingValidationError{
					field:  "AnomalyDetection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Auditing_Logging:
		if v == nil {
			err := AuditingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLogging()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuditingValidationError{
						field:  "Logging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuditingValidationError{
						field:  "Logging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLogging()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuditingValidationError{
					field:  "Logging",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Auditing_MalwareProtection:
		if v == nil {
			err := AuditingValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMalwareProtection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuditingValidationError{
						field:  "MalwareProtection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuditingValidationError{
						field:  "MalwareProtection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMalwareProtection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuditingValidationError{
					field:  "MalwareProtection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AuditingMultiError(errors)
	}

	return nil
}

// AuditingMultiError is an error wrapping multiple validation errors returned
// by Auditing.ValidateAll() if the designated constraints aren't met.
type AuditingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditingMultiError) AllErrors() []error { return m }

// AuditingValidationError is the validation error returned by
// Auditing.Validate if the designated constraints aren't met.
type AuditingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditingValidationError) ErrorName() string { return "AuditingValidationError" }

// Error satisfies the builtin error interface
func (e AuditingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditingValidationError{}

// Validate checks the field values on HttpRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HttpRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HttpRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HttpRequestMultiError, or
// nil if none found.
func (m *HttpRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HttpRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHttpEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HttpRequestValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HttpRequestValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHttpEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpRequestValidationError{
				field:  "HttpEndpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HttpRequestMultiError(errors)
	}

	return nil
}

// HttpRequestMultiError is an error wrapping multiple validation errors
// returned by HttpRequest.ValidateAll() if the designated constraints aren't met.
type HttpRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HttpRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HttpRequestMultiError) AllErrors() []error { return m }

// HttpRequestValidationError is the validation error returned by
// HttpRequest.Validate if the designated constraints aren't met.
type HttpRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpRequestValidationError) ErrorName() string { return "HttpRequestValidationError" }

// Error satisfies the builtin error interface
func (e HttpRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpRequestValidationError{}

// Validate checks the field values on Identity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Identity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Identity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IdentityMultiError, or nil
// if none found.
func (m *Identity) ValidateAll() error {
	return m.validate(true)
}

func (m *Identity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAuthenticity() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IdentityValidationError{
						field:  fmt.Sprintf("Authenticity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IdentityValidationError{
						field:  fmt.Sprintf("Authenticity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IdentityValidationError{
					field:  fmt.Sprintf("Authenticity[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IdentityMultiError(errors)
	}

	return nil
}

// IdentityMultiError is an error wrapping multiple validation errors returned
// by Identity.ValidateAll() if the designated constraints aren't met.
type IdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IdentityMultiError) AllErrors() []error { return m }

// IdentityValidationError is the validation error returned by
// Identity.Validate if the designated constraints aren't met.
type IdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IdentityValidationError) ErrorName() string { return "IdentityValidationError" }

// Error satisfies the builtin error interface
func (e IdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IdentityValidationError{}

// Validate checks the field values on TransportEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransportEncryption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransportEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransportEncryptionMultiError, or nil if none found.
func (m *TransportEncryption) ValidateAll() error {
	return m.validate(true)
}

func (m *TransportEncryption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Enforced

	for idx, item := range m.GetCipherSuite() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransportEncryptionValidationError{
						field:  fmt.Sprintf("CipherSuite[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransportEncryptionValidationError{
						field:  fmt.Sprintf("CipherSuite[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransportEncryptionValidationError{
					field:  fmt.Sprintf("CipherSuite[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransportEncryptionMultiError(errors)
	}

	return nil
}

// TransportEncryptionMultiError is an error wrapping multiple validation
// errors returned by TransportEncryption.ValidateAll() if the designated
// constraints aren't met.
type TransportEncryptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransportEncryptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransportEncryptionMultiError) AllErrors() []error { return m }

// TransportEncryptionValidationError is the validation error returned by
// TransportEncryption.Validate if the designated constraints aren't met.
type TransportEncryptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransportEncryptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransportEncryptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransportEncryptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransportEncryptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransportEncryptionValidationError) ErrorName() string {
	return "TransportEncryptionValidationError"
}

// Error satisfies the builtin error interface
func (e TransportEncryptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransportEncryption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransportEncryptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransportEncryptionValidationError{}

// Validate checks the field values on L3Firewall with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *L3Firewall) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on L3Firewall with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in L3FirewallMultiError, or
// nil if none found.
func (m *L3Firewall) ValidateAll() error {
	return m.validate(true)
}

func (m *L3Firewall) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Inbound

	// no validation rules for RestrictedPorts

	if len(errors) > 0 {
		return L3FirewallMultiError(errors)
	}

	return nil
}

// L3FirewallMultiError is an error wrapping multiple validation errors
// returned by L3Firewall.ValidateAll() if the designated constraints aren't met.
type L3FirewallMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m L3FirewallMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m L3FirewallMultiError) AllErrors() []error { return m }

// L3FirewallValidationError is the validation error returned by
// L3Firewall.Validate if the designated constraints aren't met.
type L3FirewallValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e L3FirewallValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e L3FirewallValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e L3FirewallValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e L3FirewallValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e L3FirewallValidationError) ErrorName() string { return "L3FirewallValidationError" }

// Error satisfies the builtin error interface
func (e L3FirewallValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sL3Firewall.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = L3FirewallValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = L3FirewallValidationError{}

// Validate checks the field values on VirtualNetwork with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VirtualNetwork) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VirtualNetwork with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VirtualNetworkMultiError,
// or nil if none found.
func (m *VirtualNetwork) ValidateAll() error {
	return m.validate(true)
}

func (m *VirtualNetwork) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return VirtualNetworkMultiError(errors)
	}

	return nil
}

// VirtualNetworkMultiError is an error wrapping multiple validation errors
// returned by VirtualNetwork.ValidateAll() if the designated constraints
// aren't met.
type VirtualNetworkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VirtualNetworkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VirtualNetworkMultiError) AllErrors() []error { return m }

// VirtualNetworkValidationError is the validation error returned by
// VirtualNetwork.Validate if the designated constraints aren't met.
type VirtualNetworkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VirtualNetworkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VirtualNetworkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VirtualNetworkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VirtualNetworkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VirtualNetworkValidationError) ErrorName() string { return "VirtualNetworkValidationError" }

// Error satisfies the builtin error interface
func (e VirtualNetworkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVirtualNetwork.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VirtualNetworkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VirtualNetworkValidationError{}

// Validate checks the field values on ObjectStorageService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ObjectStorageService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectStorageService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectStorageServiceMultiError, or nil if none found.
func (m *ObjectStorageService) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectStorageService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHttpEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectStorageServiceValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectStorageServiceValidationError{
					field:  "HttpEndpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHttpEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectStorageServiceValidationError{
				field:  "HttpEndpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ObjectStorageServiceMultiError(errors)
	}

	return nil
}

// ObjectStorageServiceMultiError is an error wrapping multiple validation
// errors returned by ObjectStorageService.ValidateAll() if the designated
// constraints aren't met.
type ObjectStorageServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectStorageServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectStorageServiceMultiError) AllErrors() []error { return m }

// ObjectStorageServiceValidationError is the validation error returned by
// ObjectStorageService.Validate if the designated constraints aren't met.
type ObjectStorageServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectStorageServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectStorageServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectStorageServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectStorageServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectStorageServiceValidationError) ErrorName() string {
	return "ObjectStorageServiceValidationError"
}

// Error satisfies the builtin error interface
func (e ObjectStorageServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectStorageService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectStorageServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectStorageServiceValidationError{}

// Validate checks the field values on RelationalDatabaseService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RelationalDatabaseService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationalDatabaseService with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RelationalDatabaseServiceMultiError, or nil if none found.
func (m *RelationalDatabaseService) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationalDatabaseService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RelationalDatabaseServiceMultiError(errors)
	}

	return nil
}

// RelationalDatabaseServiceMultiError is an error wrapping multiple validation
// errors returned by RelationalDatabaseService.ValidateAll() if the
// designated constraints aren't met.
type RelationalDatabaseServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationalDatabaseServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationalDatabaseServiceMultiError) AllErrors() []error { return m }

// RelationalDatabaseServiceValidationError is the validation error returned by
// RelationalDatabaseService.Validate if the designated constraints aren't met.
type RelationalDatabaseServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationalDatabaseServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationalDatabaseServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationalDatabaseServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationalDatabaseServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationalDatabaseServiceValidationError) ErrorName() string {
	return "RelationalDatabaseServiceValidationError"
}

// Error satisfies the builtin error interface
func (e RelationalDatabaseServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationalDatabaseService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationalDatabaseServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationalDatabaseServiceValidationError{}

// Validate checks the field values on Authorization with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Authorization) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Authorization with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthorizationMultiError, or
// nil if none found.
func (m *Authorization) ValidateAll() error {
	return m.validate(true)
}

func (m *Authorization) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Authorization_ABAC:
		if v == nil {
			err := AuthorizationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetABAC()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthorizationValidationError{
						field:  "ABAC",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthorizationValidationError{
						field:  "ABAC",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetABAC()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthorizationValidationError{
					field:  "ABAC",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Authorization_AccessRestriction:
		if v == nil {
			err := AuthorizationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAccessRestriction()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthorizationValidationError{
						field:  "AccessRestriction",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthorizationValidationError{
						field:  "AccessRestriction",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAccessRestriction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthorizationValidationError{
					field:  "AccessRestriction",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Authorization_RBAC:
		if v == nil {
			err := AuthorizationValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRBAC()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthorizationValidationError{
						field:  "RBAC",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthorizationValidationError{
						field:  "RBAC",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRBAC()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthorizationValidationError{
					field:  "RBAC",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AuthorizationMultiError(errors)
	}

	return nil
}

// AuthorizationMultiError is an error wrapping multiple validation errors
// returned by Authorization.ValidateAll() if the designated constraints
// aren't met.
type AuthorizationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationMultiError) AllErrors() []error { return m }

// AuthorizationValidationError is the validation error returned by
// Authorization.Validate if the designated constraints aren't met.
type AuthorizationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationValidationError) ErrorName() string { return "AuthorizationValidationError" }

// Error satisfies the builtin error interface
func (e AuthorizationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorization.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationValidationError{}

// Validate checks the field values on Function with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Function) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Function with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FunctionMultiError, or nil
// if none found.
func (m *Function) ValidateAll() error {
	return m.validate(true)
}

func (m *Function) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FunctionMultiError(errors)
	}

	return nil
}

// FunctionMultiError is an error wrapping multiple validation errors returned
// by Function.ValidateAll() if the designated constraints aren't met.
type FunctionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FunctionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FunctionMultiError) AllErrors() []error { return m }

// FunctionValidationError is the validation error returned by
// Function.Validate if the designated constraints aren't met.
type FunctionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FunctionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FunctionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FunctionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FunctionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FunctionValidationError) ErrorName() string { return "FunctionValidationError" }

// Error satisfies the builtin error interface
func (e FunctionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFunction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FunctionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FunctionValidationError{}

// Validate checks the field values on KeyValueDatabaseService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KeyValueDatabaseService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyValueDatabaseService with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KeyValueDatabaseServiceMultiError, or nil if none found.
func (m *KeyValueDatabaseService) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyValueDatabaseService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return KeyValueDatabaseServiceMultiError(errors)
	}

	return nil
}

// KeyValueDatabaseServiceMultiError is an error wrapping multiple validation
// errors returned by KeyValueDatabaseService.ValidateAll() if the designated
// constraints aren't met.
type KeyValueDatabaseServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyValueDatabaseServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyValueDatabaseServiceMultiError) AllErrors() []error { return m }

// KeyValueDatabaseServiceValidationError is the validation error returned by
// KeyValueDatabaseService.Validate if the designated constraints aren't met.
type KeyValueDatabaseServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValueDatabaseServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValueDatabaseServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValueDatabaseServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValueDatabaseServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValueDatabaseServiceValidationError) ErrorName() string {
	return "KeyValueDatabaseServiceValidationError"
}

// Error satisfies the builtin error interface
func (e KeyValueDatabaseServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyValueDatabaseService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValueDatabaseServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValueDatabaseServiceValidationError{}

// Validate checks the field values on ResourceLogging with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResourceLogging) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceLogging with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceLoggingMultiError, or nil if none found.
func (m *ResourceLogging) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceLogging) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResourceLoggingMultiError(errors)
	}

	return nil
}

// ResourceLoggingMultiError is an error wrapping multiple validation errors
// returned by ResourceLogging.ValidateAll() if the designated constraints
// aren't met.
type ResourceLoggingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceLoggingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceLoggingMultiError) AllErrors() []error { return m }

// ResourceLoggingValidationError is the validation error returned by
// ResourceLogging.Validate if the designated constraints aren't met.
type ResourceLoggingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceLoggingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceLoggingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceLoggingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceLoggingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceLoggingValidationError) ErrorName() string { return "ResourceLoggingValidationError" }

// Error satisfies the builtin error interface
func (e ResourceLoggingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceLogging.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceLoggingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceLoggingValidationError{}

// Validate checks the field values on SecurityFeature with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SecurityFeature) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityFeature with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecurityFeatureMultiError, or nil if none found.
func (m *SecurityFeature) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityFeature) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *SecurityFeature_Auditing:
		if v == nil {
			err := SecurityFeatureValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuditing()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Auditing",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Auditing",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuditing()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityFeatureValidationError{
					field:  "Auditing",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SecurityFeature_Authenticity:
		if v == nil {
			err := SecurityFeatureValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthenticity()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Authenticity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Authenticity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthenticity()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityFeatureValidationError{
					field:  "Authenticity",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SecurityFeature_Authorization:
		if v == nil {
			err := SecurityFeatureValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorization()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Authorization",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Authorization",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorization()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityFeatureValidationError{
					field:  "Authorization",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SecurityFeature_Availability:
		if v == nil {
			err := SecurityFeatureValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAvailability()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Availability",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Availability",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAvailability()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityFeatureValidationError{
					field:  "Availability",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SecurityFeature_Confidentiality:
		if v == nil {
			err := SecurityFeatureValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConfidentiality()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Confidentiality",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Confidentiality",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConfidentiality()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityFeatureValidationError{
					field:  "Confidentiality",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SecurityFeature_Integrity:
		if v == nil {
			err := SecurityFeatureValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIntegrity()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Integrity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Integrity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIntegrity()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityFeatureValidationError{
					field:  "Integrity",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SecurityFeatureMultiError(errors)
	}

	return nil
}

// SecurityFeatureMultiError is an error wrapping multiple validation errors
// returned by SecurityFeature.ValidateAll() if the designated constraints
// aren't met.
type SecurityFeatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityFeatureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityFeatureMultiError) AllErrors() []error { return m }

// SecurityFeatureValidationError is the validation error returned by
// SecurityFeature.Validate if the designated constraints aren't met.
type SecurityFeatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityFeatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityFeatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityFeatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityFeatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityFeatureValidationError) ErrorName() string { return "SecurityFeatureValidationError" }

// Error satisfies the builtin error interface
func (e SecurityFeatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityFeature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityFeatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityFeatureValidationError{}
