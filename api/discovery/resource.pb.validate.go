// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/discovery/resource.proto

package discovery

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _resource_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on ImprovedResource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImprovedResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImprovedResource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImprovedResourceMultiError, or nil if none found.
func (m *ImprovedResource) ValidateAll() error {
	return m.validate(true)
}

func (m *ImprovedResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := ImprovedResourceValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetCloudServiceId()); err != nil {
		err = ImprovedResourceValidationError{
			field:  "CloudServiceId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.Properties.(type) {
	case *ImprovedResource_VirtualMachine:
		if v == nil {
			err := ImprovedResourceValidationError{
				field:  "Properties",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVirtualMachine()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImprovedResourceValidationError{
						field:  "VirtualMachine",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImprovedResourceValidationError{
						field:  "VirtualMachine",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVirtualMachine()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImprovedResourceValidationError{
					field:  "VirtualMachine",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImprovedResource_Container:
		if v == nil {
			err := ImprovedResourceValidationError{
				field:  "Properties",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetContainer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImprovedResourceValidationError{
						field:  "Container",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImprovedResourceValidationError{
						field:  "Container",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetContainer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImprovedResourceValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ImprovedResourceMultiError(errors)
	}

	return nil
}

func (m *ImprovedResource) _validateUuid(uuid string) error {
	if matched := _resource_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ImprovedResourceMultiError is an error wrapping multiple validation errors
// returned by ImprovedResource.ValidateAll() if the designated constraints
// aren't met.
type ImprovedResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImprovedResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImprovedResourceMultiError) AllErrors() []error { return m }

// ImprovedResourceValidationError is the validation error returned by
// ImprovedResource.Validate if the designated constraints aren't met.
type ImprovedResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImprovedResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImprovedResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImprovedResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImprovedResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImprovedResourceValidationError) ErrorName() string { return "ImprovedResourceValidationError" }

// Error satisfies the builtin error interface
func (e ImprovedResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImprovedResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImprovedResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImprovedResourceValidationError{}

// Validate checks the field values on ResourceProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResourceProperties) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourcePropertiesMultiError, or nil if none found.
func (m *ResourceProperties) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceProperties) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGeoLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourcePropertiesValidationError{
					field:  "GeoLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourcePropertiesValidationError{
					field:  "GeoLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeoLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourcePropertiesValidationError{
				field:  "GeoLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResourcePropertiesMultiError(errors)
	}

	return nil
}

// ResourcePropertiesMultiError is an error wrapping multiple validation errors
// returned by ResourceProperties.ValidateAll() if the designated constraints
// aren't met.
type ResourcePropertiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourcePropertiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourcePropertiesMultiError) AllErrors() []error { return m }

// ResourcePropertiesValidationError is the validation error returned by
// ResourceProperties.Validate if the designated constraints aren't met.
type ResourcePropertiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourcePropertiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourcePropertiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourcePropertiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourcePropertiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourcePropertiesValidationError) ErrorName() string {
	return "ResourcePropertiesValidationError"
}

// Error satisfies the builtin error interface
func (e ResourcePropertiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceProperties.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourcePropertiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourcePropertiesValidationError{}

// Validate checks the field values on Compute with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Compute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Compute with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ComputeMultiError, or nil if none found.
func (m *Compute) ValidateAll() error {
	return m.validate(true)
}

func (m *Compute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputeValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputeValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputeValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComputeMultiError(errors)
	}

	return nil
}

// ComputeMultiError is an error wrapping multiple validation errors returned
// by Compute.ValidateAll() if the designated constraints aren't met.
type ComputeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputeMultiError) AllErrors() []error { return m }

// ComputeValidationError is the validation error returned by Compute.Validate
// if the designated constraints aren't met.
type ComputeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputeValidationError) ErrorName() string { return "ComputeValidationError" }

// Error satisfies the builtin error interface
func (e ComputeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputeValidationError{}

// Validate checks the field values on VirtualMachine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VirtualMachine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VirtualMachine with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VirtualMachineMultiError,
// or nil if none found.
func (m *VirtualMachine) ValidateAll() error {
	return m.validate(true)
}

func (m *VirtualMachine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCompute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "Compute",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VirtualMachineMultiError(errors)
	}

	return nil
}

// VirtualMachineMultiError is an error wrapping multiple validation errors
// returned by VirtualMachine.ValidateAll() if the designated constraints
// aren't met.
type VirtualMachineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VirtualMachineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VirtualMachineMultiError) AllErrors() []error { return m }

// VirtualMachineValidationError is the validation error returned by
// VirtualMachine.Validate if the designated constraints aren't met.
type VirtualMachineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VirtualMachineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VirtualMachineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VirtualMachineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VirtualMachineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VirtualMachineValidationError) ErrorName() string { return "VirtualMachineValidationError" }

// Error satisfies the builtin error interface
func (e VirtualMachineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVirtualMachine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VirtualMachineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VirtualMachineValidationError{}

// Validate checks the field values on Container with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Container) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Container with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerMultiError, or nil
// if none found.
func (m *Container) ValidateAll() error {
	return m.validate(true)
}

func (m *Container) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCompute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerValidationError{
				field:  "Compute",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContainerMultiError(errors)
	}

	return nil
}

// ContainerMultiError is an error wrapping multiple validation errors returned
// by Container.ValidateAll() if the designated constraints aren't met.
type ContainerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerMultiError) AllErrors() []error { return m }

// ContainerValidationError is the validation error returned by
// Container.Validate if the designated constraints aren't met.
type ContainerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerValidationError) ErrorName() string { return "ContainerValidationError" }

// Error satisfies the builtin error interface
func (e ContainerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerValidationError{}

// Validate checks the field values on Networking with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Networking) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Networking with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetworkingMultiError, or
// nil if none found.
func (m *Networking) ValidateAll() error {
	return m.validate(true)
}

func (m *Networking) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetworkingValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetworkingValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetworkingValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NetworkingMultiError(errors)
	}

	return nil
}

// NetworkingMultiError is an error wrapping multiple validation errors
// returned by Networking.ValidateAll() if the designated constraints aren't met.
type NetworkingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkingMultiError) AllErrors() []error { return m }

// NetworkingValidationError is the validation error returned by
// Networking.Validate if the designated constraints aren't met.
type NetworkingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkingValidationError) ErrorName() string { return "NetworkingValidationError" }

// Error satisfies the builtin error interface
func (e NetworkingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworking.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkingValidationError{}

// Validate checks the field values on NetworkInterface with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NetworkInterface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkInterface with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NetworkInterfaceMultiError, or nil if none found.
func (m *NetworkInterface) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkInterface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNetworking()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetworkInterfaceValidationError{
					field:  "Networking",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetworkInterfaceValidationError{
					field:  "Networking",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworking()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetworkInterfaceValidationError{
				field:  "Networking",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAccessRestriction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetworkInterfaceValidationError{
					field:  "AccessRestriction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetworkInterfaceValidationError{
					field:  "AccessRestriction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessRestriction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetworkInterfaceValidationError{
				field:  "AccessRestriction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NetworkInterfaceMultiError(errors)
	}

	return nil
}

// NetworkInterfaceMultiError is an error wrapping multiple validation errors
// returned by NetworkInterface.ValidateAll() if the designated constraints
// aren't met.
type NetworkInterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkInterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkInterfaceMultiError) AllErrors() []error { return m }

// NetworkInterfaceValidationError is the validation error returned by
// NetworkInterface.Validate if the designated constraints aren't met.
type NetworkInterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkInterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkInterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkInterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkInterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkInterfaceValidationError) ErrorName() string { return "NetworkInterfaceValidationError" }

// Error satisfies the builtin error interface
func (e NetworkInterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkInterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkInterfaceValidationError{}

// Validate checks the field values on GeoLocation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GeoLocation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeoLocation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GeoLocationMultiError, or
// nil if none found.
func (m *GeoLocation) ValidateAll() error {
	return m.validate(true)
}

func (m *GeoLocation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	if len(errors) > 0 {
		return GeoLocationMultiError(errors)
	}

	return nil
}

// GeoLocationMultiError is an error wrapping multiple validation errors
// returned by GeoLocation.ValidateAll() if the designated constraints aren't met.
type GeoLocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeoLocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeoLocationMultiError) AllErrors() []error { return m }

// GeoLocationValidationError is the validation error returned by
// GeoLocation.Validate if the designated constraints aren't met.
type GeoLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeoLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeoLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeoLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeoLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeoLocationValidationError) ErrorName() string { return "GeoLocationValidationError" }

// Error satisfies the builtin error interface
func (e GeoLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeoLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeoLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeoLocationValidationError{}

// Validate checks the field values on SecurityFeature with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SecurityFeature) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityFeature with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecurityFeatureMultiError, or nil if none found.
func (m *SecurityFeature) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityFeature) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Feature.(type) {
	case *SecurityFeature_Availability:
		if v == nil {
			err := SecurityFeatureValidationError{
				field:  "Feature",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAvailability()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Availability",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityFeatureValidationError{
						field:  "Availability",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAvailability()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityFeatureValidationError{
					field:  "Availability",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SecurityFeatureMultiError(errors)
	}

	return nil
}

// SecurityFeatureMultiError is an error wrapping multiple validation errors
// returned by SecurityFeature.ValidateAll() if the designated constraints
// aren't met.
type SecurityFeatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityFeatureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityFeatureMultiError) AllErrors() []error { return m }

// SecurityFeatureValidationError is the validation error returned by
// SecurityFeature.Validate if the designated constraints aren't met.
type SecurityFeatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityFeatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityFeatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityFeatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityFeatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityFeatureValidationError) ErrorName() string { return "SecurityFeatureValidationError" }

// Error satisfies the builtin error interface
func (e SecurityFeatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityFeature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityFeatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityFeatureValidationError{}

// Validate checks the field values on Availabilty with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Availabilty) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Availabilty with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailabiltyMultiError, or
// nil if none found.
func (m *Availabilty) ValidateAll() error {
	return m.validate(true)
}

func (m *Availabilty) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Feature.(type) {
	case *Availabilty_GeoLocation:
		if v == nil {
			err := AvailabiltyValidationError{
				field:  "Feature",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGeoLocation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AvailabiltyValidationError{
						field:  "GeoLocation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AvailabiltyValidationError{
						field:  "GeoLocation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGeoLocation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AvailabiltyValidationError{
					field:  "GeoLocation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AvailabiltyMultiError(errors)
	}

	return nil
}

// AvailabiltyMultiError is an error wrapping multiple validation errors
// returned by Availabilty.ValidateAll() if the designated constraints aren't met.
type AvailabiltyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailabiltyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailabiltyMultiError) AllErrors() []error { return m }

// AvailabiltyValidationError is the validation error returned by
// Availabilty.Validate if the designated constraints aren't met.
type AvailabiltyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailabiltyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailabiltyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailabiltyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailabiltyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailabiltyValidationError) ErrorName() string { return "AvailabiltyValidationError" }

// Error satisfies the builtin error interface
func (e AvailabiltyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailabilty.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailabiltyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailabiltyValidationError{}

// Validate checks the field values on Authorization with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Authorization) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Authorization with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthorizationMultiError, or
// nil if none found.
func (m *Authorization) ValidateAll() error {
	return m.validate(true)
}

func (m *Authorization) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Feature.(type) {
	case *Authorization_AccessRestriction:
		if v == nil {
			err := AuthorizationValidationError{
				field:  "Feature",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAccessRestriction()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthorizationValidationError{
						field:  "AccessRestriction",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthorizationValidationError{
						field:  "AccessRestriction",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAccessRestriction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthorizationValidationError{
					field:  "AccessRestriction",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AuthorizationMultiError(errors)
	}

	return nil
}

// AuthorizationMultiError is an error wrapping multiple validation errors
// returned by Authorization.ValidateAll() if the designated constraints
// aren't met.
type AuthorizationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationMultiError) AllErrors() []error { return m }

// AuthorizationValidationError is the validation error returned by
// Authorization.Validate if the designated constraints aren't met.
type AuthorizationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationValidationError) ErrorName() string { return "AuthorizationValidationError" }

// Error satisfies the builtin error interface
func (e AuthorizationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorization.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationValidationError{}

// Validate checks the field values on RBAC with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *RBAC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RBAC with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RBACMultiError, or nil if none found.
func (m *RBAC) ValidateAll() error {
	return m.validate(true)
}

func (m *RBAC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RBACMultiError(errors)
	}

	return nil
}

// RBACMultiError is an error wrapping multiple validation errors returned by
// RBAC.ValidateAll() if the designated constraints aren't met.
type RBACMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RBACMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RBACMultiError) AllErrors() []error { return m }

// RBACValidationError is the validation error returned by RBAC.Validate if the
// designated constraints aren't met.
type RBACValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RBACValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RBACValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RBACValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RBACValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RBACValidationError) ErrorName() string { return "RBACValidationError" }

// Error satisfies the builtin error interface
func (e RBACValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRBAC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RBACValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RBACValidationError{}

// Validate checks the field values on ABAC with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *ABAC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABAC with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ABACMultiError, or nil if none found.
func (m *ABAC) ValidateAll() error {
	return m.validate(true)
}

func (m *ABAC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ABACMultiError(errors)
	}

	return nil
}

// ABACMultiError is an error wrapping multiple validation errors returned by
// ABAC.ValidateAll() if the designated constraints aren't met.
type ABACMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABACMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABACMultiError) AllErrors() []error { return m }

// ABACValidationError is the validation error returned by ABAC.Validate if the
// designated constraints aren't met.
type ABACValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABACValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABACValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABACValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABACValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABACValidationError) ErrorName() string { return "ABACValidationError" }

// Error satisfies the builtin error interface
func (e ABACValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABAC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABACValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABACValidationError{}

// Validate checks the field values on AccessRestriction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AccessRestriction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccessRestriction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccessRestrictionMultiError, or nil if none found.
func (m *AccessRestriction) ValidateAll() error {
	return m.validate(true)
}

func (m *AccessRestriction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Feature.(type) {
	case *AccessRestriction_Firewall:
		if v == nil {
			err := AccessRestrictionValidationError{
				field:  "Feature",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFirewall()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AccessRestrictionValidationError{
						field:  "Firewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AccessRestrictionValidationError{
						field:  "Firewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFirewall()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AccessRestrictionValidationError{
					field:  "Firewall",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AccessRestrictionMultiError(errors)
	}

	return nil
}

// AccessRestrictionMultiError is an error wrapping multiple validation errors
// returned by AccessRestriction.ValidateAll() if the designated constraints
// aren't met.
type AccessRestrictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccessRestrictionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccessRestrictionMultiError) AllErrors() []error { return m }

// AccessRestrictionValidationError is the validation error returned by
// AccessRestriction.Validate if the designated constraints aren't met.
type AccessRestrictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccessRestrictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccessRestrictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccessRestrictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccessRestrictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccessRestrictionValidationError) ErrorName() string {
	return "AccessRestrictionValidationError"
}

// Error satisfies the builtin error interface
func (e AccessRestrictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccessRestriction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccessRestrictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccessRestrictionValidationError{}

// Validate checks the field values on Firewall with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Firewall) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Firewall with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirewallMultiError, or nil
// if none found.
func (m *Firewall) ValidateAll() error {
	return m.validate(true)
}

func (m *Firewall) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Class.(type) {
	case *Firewall_L3Firewall:
		if v == nil {
			err := FirewallValidationError{
				field:  "Class",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetL3Firewall()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FirewallValidationError{
						field:  "L3Firewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FirewallValidationError{
						field:  "L3Firewall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetL3Firewall()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FirewallValidationError{
					field:  "L3Firewall",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FirewallMultiError(errors)
	}

	return nil
}

// FirewallMultiError is an error wrapping multiple validation errors returned
// by Firewall.ValidateAll() if the designated constraints aren't met.
type FirewallMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirewallMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirewallMultiError) AllErrors() []error { return m }

// FirewallValidationError is the validation error returned by
// Firewall.Validate if the designated constraints aren't met.
type FirewallValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirewallValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirewallValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirewallValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirewallValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirewallValidationError) ErrorName() string { return "FirewallValidationError" }

// Error satisfies the builtin error interface
func (e FirewallValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirewall.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirewallValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirewallValidationError{}

// Validate checks the field values on L3Firewall with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *L3Firewall) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on L3Firewall with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in L3FirewallMultiError, or
// nil if none found.
func (m *L3Firewall) ValidateAll() error {
	return m.validate(true)
}

func (m *L3Firewall) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Inbound

	if len(errors) > 0 {
		return L3FirewallMultiError(errors)
	}

	return nil
}

// L3FirewallMultiError is an error wrapping multiple validation errors
// returned by L3Firewall.ValidateAll() if the designated constraints aren't met.
type L3FirewallMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m L3FirewallMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m L3FirewallMultiError) AllErrors() []error { return m }

// L3FirewallValidationError is the validation error returned by
// L3Firewall.Validate if the designated constraints aren't met.
type L3FirewallValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e L3FirewallValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e L3FirewallValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e L3FirewallValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e L3FirewallValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e L3FirewallValidationError) ErrorName() string { return "L3FirewallValidationError" }

// Error satisfies the builtin error interface
func (e L3FirewallValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sL3Firewall.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = L3FirewallValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = L3FirewallValidationError{}
