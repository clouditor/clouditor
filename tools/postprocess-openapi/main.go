// Copyright 2025 Fraunhofer AISEC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"gopkg.in/yaml.v3"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <service-dir> [<service-dir2> ...]\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Example: %s openapi/assessment openapi/evaluation\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "\nPost-processes OpenAPI files generated by buf:\n")
		fmt.Fprintf(os.Stderr, "  1. Moves openapi/service/openapi.yaml -> openapi/service.yaml\n")
		fmt.Fprintf(os.Stderr, "  2. Fixes duplicate operationIds from additional_bindings\n")
		os.Exit(1)
	}

	for _, serviceDir := range os.Args[1:] {
		if err := processServiceDir(serviceDir); err != nil {
			log.Fatalf("Error processing %s: %v", serviceDir, err)
		}
	}
}

func processServiceDir(serviceDir string) error {
	// Step 1: Move openapi.yaml to parent with service name
	inputFile := filepath.Join(serviceDir, "openapi.yaml")
	serviceName := filepath.Base(serviceDir)
	outputFile := filepath.Join(filepath.Dir(serviceDir), serviceName+".yaml")

	fmt.Printf("Processing %s...\n", serviceDir)

	// Check if input file exists
	if _, err := os.Stat(inputFile); os.IsNotExist(err) {
		return fmt.Errorf("input file %s does not exist", inputFile)
	}

	// Step 2: Process the file (fix operationIds)
	if err := processFile(inputFile, outputFile); err != nil {
		return err
	}

	fmt.Printf("  Moved and processed: %s -> %s\n", inputFile, outputFile)

	return nil
}

func processFile(inputPath, outputPath string) error {
	// Read the file
	data, err := os.ReadFile(inputPath)
	if err != nil {
		return fmt.Errorf("reading file: %w", err)
	}

	// Parse as generic YAML to preserve structure
	var doc yaml.Node
	if err := yaml.Unmarshal(data, &doc); err != nil {
		return fmt.Errorf("parsing YAML: %w", err)
	}

	// Process the document (fix operationIds)
	changes := 0
	if doc.Kind == yaml.DocumentNode && len(doc.Content) > 0 {
		changes = processDocument(doc.Content[0])
	}

	// Write to output file
	output, err := yaml.Marshal(&doc)
	if err != nil {
		return fmt.Errorf("marshaling YAML: %w", err)
	}

	if err := os.WriteFile(outputPath, output, 0644); err != nil {
		return fmt.Errorf("writing file: %w", err)
	}

	// Remove the original file after successful write
	if inputPath != outputPath {
		if err := os.Remove(inputPath); err != nil {
			return fmt.Errorf("removing original file: %w", err)
		}

		// Try to remove the now-empty service directory
		serviceDir := filepath.Dir(inputPath)
		if err := os.Remove(serviceDir); err != nil {
			// Ignore error if directory is not empty or doesn't exist
		}
	}

	if changes > 0 {
		fmt.Printf("  Fixed %d duplicate operationId(s)\n", changes)
	}

	return nil
}

func processDocument(root *yaml.Node) int {
	// Find the "paths" node
	pathsNode := findMapValue(root, "paths")
	if pathsNode == nil {
		return 0
	}

	// Collect all operationIds and their paths to detect duplicates
	operationCounts := make(map[string]int)
	pathOrder := []struct {
		path   string
		method string
		opID   string
	}{}

	// First pass: count operationIds and preserve order
	if pathsNode.Kind == yaml.MappingNode {
		for i := 0; i < len(pathsNode.Content); i += 2 {
			pathKey := pathsNode.Content[i].Value
			pathValue := pathsNode.Content[i+1]

			// Iterate over HTTP methods in this path
			if pathValue.Kind == yaml.MappingNode {
				for j := 0; j < len(pathValue.Content); j += 2 {
					method := pathValue.Content[j].Value
					operation := pathValue.Content[j+1]

					// Look for operationId
					operationIDNode := findMapValue(operation, "operationId")
					if operationIDNode != nil && operationIDNode.Value != "" {
						operationID := operationIDNode.Value
						operationCounts[operationID]++
						pathOrder = append(pathOrder, struct {
							path   string
							method string
							opID   string
						}{pathKey, method, operationID})
					}
				}
			}
		}
	}

	// Build the new operation ID map
	seenOperations := make(map[string][]string)
	operationIDMap := make(map[string]string) // key: "path:method", value: new operationId

	for _, item := range pathOrder {
		key := item.path + ":" + item.method
		// Only make unique if there are duplicates
		if operationCounts[item.opID] > 1 {
			newOperationID := makeUniqueOperationID(item.opID, item.path, seenOperations)
			operationIDMap[key] = newOperationID
		} else {
			operationIDMap[key] = item.opID
		}
	}

	// Second pass: update operationIds
	changes := 0
	if pathsNode.Kind == yaml.MappingNode {
		for i := 0; i < len(pathsNode.Content); i += 2 {
			pathKey := pathsNode.Content[i].Value
			pathValue := pathsNode.Content[i+1]

			if pathValue.Kind == yaml.MappingNode {
				for j := 0; j < len(pathValue.Content); j += 2 {
					method := pathValue.Content[j].Value
					operation := pathValue.Content[j+1]

					operationIDNode := findMapValue(operation, "operationId")
					if operationIDNode != nil && operationIDNode.Value != "" {
						key := pathKey + ":" + method
						newID := operationIDMap[key]
						if operationIDNode.Value != newID {
							fmt.Printf("  %s (%s) -> %s\n", operationIDNode.Value, pathKey, newID)
							operationIDNode.Value = newID
							changes++
						}
					}
				}
			}
		}
	}

	return changes
}

func findMapValue(node *yaml.Node, key string) *yaml.Node {
	if node.Kind != yaml.MappingNode {
		return nil
	}

	for i := 0; i < len(node.Content); i += 2 {
		if node.Content[i].Value == key {
			return node.Content[i+1]
		}
	}

	return nil
}

func makeUniqueOperationID(operationID, path string, seenOperations map[string][]string) string {
	if _, exists := seenOperations[operationID]; !exists {
		seenOperations[operationID] = []string{}
	}

	// Extract path variables like {catalog_id}, {category_name}
	re := regexp.MustCompile(`\{([^}]+)\}`)
	matches := re.FindAllStringSubmatch(path, -1)

	// Routes without path parameters keep the original name (they're the "base" route)
	if len(matches) == 0 {
		seenOperations[operationID] = append(seenOperations[operationID], path)
		return operationID
	}

	// For routes with path parameters, generate a suffix
	var parts []string
	for _, match := range matches {
		varName := match[1]
		// Remove common suffixes like _id, _name
		cleanVar := regexp.MustCompile(`_(id|name)$`).ReplaceAllString(varName, "")
		// Convert to PascalCase
		pascal := toPascalCase(cleanVar)
		parts = append(parts, pascal)
	}

	suffix := "_By" + strings.Join(parts, "And")

	seenOperations[operationID] = append(seenOperations[operationID], path)
	return operationID + suffix
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
